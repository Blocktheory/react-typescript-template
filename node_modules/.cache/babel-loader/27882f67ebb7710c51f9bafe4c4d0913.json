{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { isThenable } from '../../lib/is-thenable';\nimport { version } from '../../generated/version';\n\nvar flushSyncAnalyticsCalls = function (name, analytics, buffer) {\n  buffer.getCalls(name).forEach(function (c) {\n    // While the underlying methods are synchronous, the callAnalyticsMethod returns a promise,\n    // which normalizes success and error states between async and non-async methods, with no perf penalty.\n    callAnalyticsMethod(analytics, c).catch(console.error);\n  });\n};\n\nexport var flushAddSourceMiddleware = function (analytics, buffer) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var _i, _a, c;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _i = 0, _a = buffer.getCalls('addSourceMiddleware');\n          _b.label = 1;\n\n        case 1:\n          if (!(_i < _a.length)) return [3\n          /*break*/\n          , 4];\n          c = _a[_i];\n          return [4\n          /*yield*/\n          , callAnalyticsMethod(analytics, c).catch(console.error)];\n\n        case 2:\n          _b.sent();\n\n          _b.label = 3;\n\n        case 3:\n          _i++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 4:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n};\nexport var flushOn = flushSyncAnalyticsCalls.bind(this, 'on');\nexport var flushSetAnonymousID = flushSyncAnalyticsCalls.bind(this, 'setAnonymousId');\nexport var flushAnalyticsCallsInNewTask = function (analytics, buffer) {\n  buffer.toArray().forEach(function (m) {\n    setTimeout(function () {\n      callAnalyticsMethod(analytics, m).catch(console.error);\n    }, 0);\n  });\n};\n/**\n *  Represents any and all the buffered method calls that occurred before initialization.\n */\n\nvar PreInitMethodCallBuffer =\n/** @class */\nfunction () {\n  function PreInitMethodCallBuffer() {\n    this._value = {};\n  }\n\n  PreInitMethodCallBuffer.prototype.toArray = function () {\n    var _a;\n\n    return (_a = []).concat.apply(_a, Object.values(this._value));\n  };\n\n  PreInitMethodCallBuffer.prototype.getCalls = function (methodName) {\n    var _a;\n\n    return (_a = this._value[methodName]) !== null && _a !== void 0 ? _a : [];\n  };\n\n  PreInitMethodCallBuffer.prototype.push = function () {\n    var _this = this;\n\n    var calls = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      calls[_i] = arguments[_i];\n    }\n\n    calls.forEach(function (call) {\n      if (_this._value[call.method]) {\n        _this._value[call.method].push(call);\n      } else {\n        _this._value[call.method] = [call];\n      }\n    });\n    return this;\n  };\n\n  PreInitMethodCallBuffer.prototype.clear = function () {\n    this._value = {};\n    return this;\n  };\n\n  return PreInitMethodCallBuffer;\n}();\n\nexport { PreInitMethodCallBuffer };\n/**\n *  Call method and mark as \"called\"\n *  This function should never throw an error\n */\n\nexport function callAnalyticsMethod(analytics, call) {\n  return __awaiter(this, void 0, void 0, function () {\n    var result, err_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          _a.trys.push([0, 3,, 4]);\n\n          if (call.called) {\n            return [2\n            /*return*/\n            , undefined];\n          }\n\n          call.called = true;\n          result = analytics[call.method].apply(analytics, call.args);\n          if (!isThenable(result)) return [3\n          /*break*/\n          , 2]; // do not defer for non-async methods\n\n          return [4\n          /*yield*/\n          , result];\n\n        case 1:\n          // do not defer for non-async methods\n          _a.sent();\n\n          _a.label = 2;\n\n        case 2:\n          call.resolve(result);\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          err_1 = _a.sent();\n          call.reject(err_1);\n          return [3\n          /*break*/\n          , 4];\n\n        case 4:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nvar AnalyticsBuffered =\n/** @class */\nfunction () {\n  function AnalyticsBuffered(loader) {\n    var _this = this;\n\n    this._preInitBuffer = new PreInitMethodCallBuffer();\n    this.trackSubmit = this._createMethod('trackSubmit');\n    this.trackClick = this._createMethod('trackClick');\n    this.trackLink = this._createMethod('trackLink');\n    this.pageView = this._createMethod('pageview');\n    this.identify = this._createMethod('identify');\n    this.reset = this._createMethod('reset');\n    this.group = this._createMethod('group');\n    this.track = this._createMethod('track');\n    this.ready = this._createMethod('ready');\n    this.alias = this._createMethod('alias');\n    this.debug = this._createChainableMethod('debug');\n    this.page = this._createMethod('page');\n    this.once = this._createChainableMethod('once');\n    this.off = this._createChainableMethod('off');\n    this.on = this._createChainableMethod('on');\n    this.addSourceMiddleware = this._createMethod('addSourceMiddleware');\n    this.setAnonymousId = this._createMethod('setAnonymousId');\n    this.addDestinationMiddleware = this._createMethod('addDestinationMiddleware');\n    this.screen = this._createMethod('screen');\n    this.register = this._createMethod('register');\n    this.deregister = this._createMethod('deregister');\n    this.user = this._createMethod('user');\n    this.VERSION = version;\n    this._promise = loader(this._preInitBuffer);\n\n    this._promise.then(function (_a) {\n      var ajs = _a[0],\n          ctx = _a[1];\n      _this.instance = ajs;\n      _this.ctx = ctx;\n    }).catch(function () {// intentionally do nothing...\n      // this result of this promise will be caught by the 'catch' block on this class.\n    });\n  }\n\n  AnalyticsBuffered.prototype.then = function () {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return (_a = this._promise).then.apply(_a, args);\n  };\n\n  AnalyticsBuffered.prototype.catch = function () {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return (_a = this._promise).catch.apply(_a, args);\n  };\n\n  AnalyticsBuffered.prototype.finally = function () {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return (_a = this._promise).finally.apply(_a, args);\n  };\n\n  AnalyticsBuffered.prototype._createMethod = function (methodName) {\n    var _this = this;\n\n    return function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      if (_this.instance) {\n        var result = (_a = _this.instance)[methodName].apply(_a, args);\n\n        return Promise.resolve(result);\n      }\n\n      return new Promise(function (resolve, reject) {\n        _this._preInitBuffer.push({\n          method: methodName,\n          args: args,\n          resolve: resolve,\n          reject: reject,\n          called: false\n        });\n      });\n    };\n  };\n  /**\n   *  These are for methods that where determining when the method gets \"flushed\" is not important.\n   *  These methods will resolve when analytics is fully initialized, and return type (other than Analytics)will not be available.\n   */\n\n\n  AnalyticsBuffered.prototype._createChainableMethod = function (methodName) {\n    var _this = this;\n\n    return function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      if (_this.instance) {\n        void (_a = _this.instance)[methodName].apply(_a, args);\n        return _this;\n      } else {\n        _this._preInitBuffer.push({\n          method: methodName,\n          args: args,\n          resolve: function () {},\n          reject: console.error,\n          called: false\n        });\n      }\n\n      return _this;\n    };\n  };\n\n  return AnalyticsBuffered;\n}();\n\nexport { AnalyticsBuffered };","map":{"version":3,"sources":["/Users/apple/Sites/react-typescript-template/node_modules/@segment/analytics-next/src/core/buffer/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Analytics } from '../analytics'\nimport { Context } from '../context'\nimport { isThenable } from '../../lib/is-thenable'\nimport { AnalyticsBrowserCore } from '../analytics/interfaces'\nimport { version } from '../../generated/version'\n\n/**\n * The names of any AnalyticsBrowser methods that also exist on Analytics\n */\nexport type PreInitMethodName =\n  | 'screen'\n  | 'register'\n  | 'deregister'\n  | 'user'\n  | 'trackSubmit'\n  | 'trackClick'\n  | 'trackLink'\n  | 'trackForm'\n  | 'pageview'\n  | 'identify'\n  | 'reset'\n  | 'group'\n  | 'track'\n  | 'ready'\n  | 'alias'\n  | 'debug'\n  | 'page'\n  | 'once'\n  | 'off'\n  | 'on'\n  | 'addSourceMiddleware'\n  | 'setAnonymousId'\n  | 'addDestinationMiddleware'\n\n// Union of all analytics methods that _do not_ return a Promise\ntype SyncPreInitMethodName = {\n  [MethodName in PreInitMethodName]: ReturnType<\n    Analytics[MethodName]\n  > extends Promise<any>\n    ? never\n    : MethodName\n}[PreInitMethodName]\n\nconst flushSyncAnalyticsCalls = (\n  name: SyncPreInitMethodName,\n  analytics: Analytics,\n  buffer: PreInitMethodCallBuffer\n): void => {\n  buffer.getCalls(name).forEach((c) => {\n    // While the underlying methods are synchronous, the callAnalyticsMethod returns a promise,\n    // which normalizes success and error states between async and non-async methods, with no perf penalty.\n    callAnalyticsMethod(analytics, c).catch(console.error)\n  })\n}\n\nexport const flushAddSourceMiddleware = async (\n  analytics: Analytics,\n  buffer: PreInitMethodCallBuffer\n) => {\n  for (const c of buffer.getCalls('addSourceMiddleware')) {\n    await callAnalyticsMethod(analytics, c).catch(console.error)\n  }\n}\n\nexport const flushOn = flushSyncAnalyticsCalls.bind(this, 'on')\n\nexport const flushSetAnonymousID = flushSyncAnalyticsCalls.bind(\n  this,\n  'setAnonymousId'\n)\n\nexport const flushAnalyticsCallsInNewTask = (\n  analytics: Analytics,\n  buffer: PreInitMethodCallBuffer\n): void => {\n  buffer.toArray().forEach((m) => {\n    setTimeout(() => {\n      callAnalyticsMethod(analytics, m).catch(console.error)\n    }, 0)\n  })\n}\n\n/**\n *  Represents a buffered method call that occurred before initialization.\n */\nexport interface PreInitMethodCall<\n  MethodName extends PreInitMethodName = PreInitMethodName\n> {\n  method: MethodName\n  args: PreInitMethodParams<MethodName>\n  called: boolean\n  resolve: (v: ReturnType<Analytics[MethodName]>) => void\n  reject: (reason: any) => void\n}\n\nexport type PreInitMethodParams<MethodName extends PreInitMethodName> =\n  Parameters<Analytics[MethodName]>\n\n/**\n * Infer return type; if return type is promise, unwrap it.\n */\ntype ReturnTypeUnwrap<Fn> = Fn extends (...args: any[]) => infer ReturnT\n  ? ReturnT extends PromiseLike<infer Unwrapped>\n    ? Unwrapped\n    : ReturnT\n  : never\n\ntype MethodCallMap = Partial<Record<PreInitMethodName, PreInitMethodCall[]>>\n\n/**\n *  Represents any and all the buffered method calls that occurred before initialization.\n */\nexport class PreInitMethodCallBuffer {\n  private _value = {} as MethodCallMap\n\n  toArray(): PreInitMethodCall[] {\n    return ([] as PreInitMethodCall[]).concat(...Object.values(this._value))\n  }\n\n  getCalls<T extends PreInitMethodName>(methodName: T): PreInitMethodCall<T>[] {\n    return (this._value[methodName] ?? []) as PreInitMethodCall<T>[]\n  }\n\n  push(...calls: PreInitMethodCall[]): PreInitMethodCallBuffer {\n    calls.forEach((call) => {\n      if (this._value[call.method]) {\n        this._value[call.method]!.push(call)\n      } else {\n        this._value[call.method] = [call]\n      }\n    })\n    return this\n  }\n\n  clear(): PreInitMethodCallBuffer {\n    this._value = {} as MethodCallMap\n    return this\n  }\n}\n\n/**\n *  Call method and mark as \"called\"\n *  This function should never throw an error\n */\nexport async function callAnalyticsMethod<T extends PreInitMethodName>(\n  analytics: Analytics,\n  call: PreInitMethodCall<T>\n): Promise<void> {\n  try {\n    if (call.called) {\n      return undefined\n    }\n    call.called = true\n\n    const result: ReturnType<Analytics[T]> = (\n      analytics[call.method] as Function\n    )(...call.args)\n\n    if (isThenable(result)) {\n      // do not defer for non-async methods\n      await result\n    }\n\n    call.resolve(result)\n  } catch (err) {\n    call.reject(err)\n  }\n}\n\nexport type AnalyticsLoader = (\n  preInitBuffer: PreInitMethodCallBuffer\n) => Promise<[Analytics, Context]>\n\nexport class AnalyticsBuffered\n  implements PromiseLike<[Analytics, Context]>, AnalyticsBrowserCore\n{\n  instance?: Analytics\n  ctx?: Context\n  private _preInitBuffer = new PreInitMethodCallBuffer()\n  private _promise: Promise<[Analytics, Context]>\n  constructor(loader: AnalyticsLoader) {\n    this._promise = loader(this._preInitBuffer)\n    this._promise\n      .then(([ajs, ctx]) => {\n        this.instance = ajs\n        this.ctx = ctx\n      })\n      .catch(() => {\n        // intentionally do nothing...\n        // this result of this promise will be caught by the 'catch' block on this class.\n      })\n  }\n\n  then<T1, T2 = never>(\n    ...args: [\n      onfulfilled:\n        | ((instance: [Analytics, Context]) => T1 | PromiseLike<T1>)\n        | null\n        | undefined,\n      onrejected?: (reason: unknown) => T2 | PromiseLike<T2>\n    ]\n  ) {\n    return this._promise.then(...args)\n  }\n\n  catch<TResult = never>(\n    ...args: [\n      onrejected?:\n        | ((reason: any) => TResult | PromiseLike<TResult>)\n        | undefined\n        | null\n    ]\n  ) {\n    return this._promise.catch(...args)\n  }\n\n  finally(...args: [onfinally?: (() => void) | undefined | null]) {\n    return this._promise.finally(...args)\n  }\n\n  trackSubmit = this._createMethod('trackSubmit')\n  trackClick = this._createMethod('trackClick')\n  trackLink = this._createMethod('trackLink')\n  pageView = this._createMethod('pageview')\n  identify = this._createMethod('identify')\n  reset = this._createMethod('reset')\n  group = this._createMethod('group') as AnalyticsBrowserCore['group']\n  track = this._createMethod('track')\n  ready = this._createMethod('ready')\n  alias = this._createMethod('alias')\n  debug = this._createChainableMethod('debug')\n  page = this._createMethod('page')\n  once = this._createChainableMethod('once')\n  off = this._createChainableMethod('off')\n  on = this._createChainableMethod('on')\n  addSourceMiddleware = this._createMethod('addSourceMiddleware')\n  setAnonymousId = this._createMethod('setAnonymousId')\n  addDestinationMiddleware = this._createMethod('addDestinationMiddleware')\n\n  screen = this._createMethod('screen')\n  register = this._createMethod('register')\n  deregister = this._createMethod('deregister')\n  user = this._createMethod('user')\n  readonly VERSION = version\n\n  private _createMethod<T extends PreInitMethodName>(methodName: T) {\n    return (\n      ...args: Parameters<Analytics[T]>\n    ): Promise<ReturnTypeUnwrap<Analytics[T]>> => {\n      if (this.instance) {\n        const result = (this.instance[methodName] as Function)(...args)\n        return Promise.resolve(result)\n      }\n\n      return new Promise((resolve, reject) => {\n        this._preInitBuffer.push({\n          method: methodName,\n          args,\n          resolve: resolve,\n          reject: reject,\n          called: false,\n        } as PreInitMethodCall)\n      })\n    }\n  }\n\n  /**\n   *  These are for methods that where determining when the method gets \"flushed\" is not important.\n   *  These methods will resolve when analytics is fully initialized, and return type (other than Analytics)will not be available.\n   */\n  private _createChainableMethod<T extends PreInitMethodName>(methodName: T) {\n    return (...args: Parameters<Analytics[T]>): AnalyticsBuffered => {\n      if (this.instance) {\n        void (this.instance[methodName] as Function)(...args)\n        return this\n      } else {\n        this._preInitBuffer.push({\n          method: methodName,\n          args,\n          resolve: () => {},\n          reject: console.error,\n          called: false,\n        } as PreInitMethodCall)\n      }\n\n      return this\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}