{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar dlv_1 = __importDefault(require(\"dlv\"));\n\nfunction matches(event, matcher) {\n  if (!matcher) {\n    throw new Error('No matcher supplied!');\n  }\n\n  switch (matcher.type) {\n    case 'all':\n      return all();\n\n    case 'fql':\n      return fql(matcher.ir, event);\n\n    default:\n      throw new Error(\"Matcher of type \".concat(matcher.type, \" unsupported.\"));\n  }\n}\n\nexports.default = matches;\n\nfunction all() {\n  return true;\n}\n\nfunction fql(ir, event) {\n  if (!ir) {\n    return false;\n  }\n\n  try {\n    ir = JSON.parse(ir);\n  } catch (e) {\n    throw new Error(\"Failed to JSON.parse FQL intermediate representation \\\"\".concat(ir, \"\\\": \").concat(e));\n  }\n\n  var result = fqlEvaluate(ir, event);\n\n  if (typeof result !== 'boolean') {\n    // An error was returned, or a lowercase, typeof, or similar function was run alone. Nothing to evaluate.\n    return false;\n  }\n\n  return result;\n} // FQL is 100% type strict in Go. Show no mercy to types which do not comply.\n\n\nfunction fqlEvaluate(ir, event) {\n  // If the given ir chunk is not an array, then we should check the single given path or value for literally `true`.\n  if (!Array.isArray(ir)) {\n    return getValue(ir, event) === true;\n  } // Otherwise, it is a sequence of ordered steps to follow to reach our solution!\n\n\n  var item = ir[0];\n\n  switch (item) {\n    /*** Unary cases ***/\n    // '!' => Invert the result\n    case '!':\n      return !fqlEvaluate(ir[1], event);\n\n    /*** Binary cases ***/\n    // 'or' => Any condition being true returns true\n\n    case 'or':\n      for (var i = 1; i < ir.length; i++) {\n        if (fqlEvaluate(ir[i], event)) {\n          return true;\n        }\n      }\n\n      return false;\n    // 'and' => Any condition being false returns false\n\n    case 'and':\n      for (var i = 1; i < ir.length; i++) {\n        if (!fqlEvaluate(ir[i], event)) {\n          return false;\n        }\n      }\n\n      return true;\n    // Equivalence comparisons\n\n    case '=':\n    case '!=':\n      return compareItems(getValue(ir[1], event), getValue(ir[2], event), item, event);\n    // Numerical comparisons\n\n    case '<=':\n    case '<':\n    case '>':\n    case '>=':\n      // Compare the two values with the given operator.\n      return compareNumbers(getValue(ir[1], event), getValue(ir[2], event), item, event);\n\n    /*** Functions ***/\n    // 'contains(str1, str2)' => The first string has a substring of the second string\n\n    case 'contains':\n      return contains(getValue(ir[1], event), getValue(ir[2], event));\n    // 'match(str, match)' => The given string matches the provided glob matcher\n\n    case 'match':\n      return match(getValue(ir[1], event), getValue(ir[2], event));\n    // 'lowercase(str)' => Returns a lowercased string, null if the item is not a string\n\n    case 'lowercase':\n      var target = getValue(ir[1], event);\n\n      if (typeof target !== 'string') {\n        return null;\n      }\n\n      return target.toLowerCase();\n    // 'typeof(val)' => Returns the FQL type of the value\n\n    case 'typeof':\n      // TODO: Do we need mapping to allow for universal comparisons? e.g. Object -> JSON, Array -> List, Floats?\n      return typeof getValue(ir[1], event);\n    // 'length(val)' => Returns the length of an array or string, NaN if neither\n\n    case 'length':\n      return length(getValue(ir[1], event));\n    // If nothing hit, we or the IR messed up somewhere.\n\n    default:\n      throw new Error(\"FQL IR could not evaluate for token: \".concat(item));\n  }\n}\n\nfunction getValue(item, event) {\n  // If item is an array, leave it as-is.\n  if (Array.isArray(item)) {\n    return item;\n  } // If item is an object, it has the form of `{\"value\": VAL}`\n\n\n  if (typeof item === 'object') {\n    return item.value;\n  } // Otherwise, it's an event path, e.g. \"properties.email\"\n\n\n  return (0, dlv_1.default)(event, item);\n}\n\nfunction compareNumbers(first, second, operator, event) {\n  // Check if it's more IR (such as a length() function)\n  if (isIR(first)) {\n    first = fqlEvaluate(first, event);\n  }\n\n  if (isIR(second)) {\n    second = fqlEvaluate(second, event);\n  }\n\n  if (typeof first !== 'number' || typeof second !== 'number') {\n    return false;\n  } // Reminder: NaN is not comparable to any other number (including NaN) and will always return false as desired.\n\n\n  switch (operator) {\n    // '<=' => The first number is less than or equal to the second.\n    case '<=':\n      return first <= second;\n    // '>=' => The first number is greater than or equal to the second\n\n    case '>=':\n      return first >= second;\n    // '<' The first number is less than the second.\n\n    case '<':\n      return first < second;\n    // '>' The first number is greater than the second.\n\n    case '>':\n      return first > second;\n\n    default:\n      throw new Error(\"Invalid operator in compareNumbers: \".concat(operator));\n  }\n}\n\nfunction compareItems(first, second, operator, event) {\n  // Check if it's more IR (such as a lowercase() function)\n  if (isIR(first)) {\n    first = fqlEvaluate(first, event);\n  }\n\n  if (isIR(second)) {\n    second = fqlEvaluate(second, event);\n  }\n\n  if (typeof first === 'object' && typeof second === 'object') {\n    first = JSON.stringify(first);\n    second = JSON.stringify(second);\n  } // Objects with the exact same contents AND order ARE considered identical. (Don't compare by reference)\n  // Even in Go, this MUST be the same byte order.\n  // e.g. {a: 1, b:2} === {a: 1, b:2} BUT {a:1, b:2} !== {b:2, a:1}\n  // Maybe later we'll use a stable stringifier, but we're matching server-side behavior for now.\n\n\n  switch (operator) {\n    // '=' => The two following items are exactly identical\n    case '=':\n      return first === second;\n    // '!=' => The two following items are NOT exactly identical.\n\n    case '!=':\n      return first !== second;\n\n    default:\n      throw new Error(\"Invalid operator in compareItems: \".concat(operator));\n  }\n}\n\nfunction contains(first, second) {\n  if (typeof first !== 'string' || typeof second !== 'string') {\n    return false;\n  }\n\n  return first.indexOf(second) !== -1;\n}\n\nfunction match(str, glob) {\n  if (typeof str !== 'string' || typeof glob !== 'string') {\n    return false;\n  }\n\n  return globMatches(glob, str);\n}\n\nfunction length(item) {\n  // Match server-side behavior.\n  if (item === null) {\n    return 0;\n  } // Type-check to avoid returning .length of an object\n\n\n  if (!Array.isArray(item) && typeof item !== 'string') {\n    return NaN;\n  }\n\n  return item.length;\n} // This is a heuristic technically speaking, but should be close enough. The odds of someone trying to test\n// a func with identical IR notation is pretty low.\n\n\nfunction isIR(value) {\n  // TODO: This can be better checked by checking if this is a {\"value\": THIS}\n  if (!Array.isArray(value)) {\n    return false;\n  } // Function checks\n\n\n  if ((value[0] === 'lowercase' || value[0] === 'length' || value[0] === 'typeof') && value.length === 2) {\n    return true;\n  }\n\n  if ((value[0] === 'contains' || value[0] === 'match') && value.length === 3) {\n    return true;\n  }\n\n  return false;\n} // Any reputable glob matcher is designed to work on filesystems and doesn't allow the override of the separator\n// character \"/\". This is problematic since our server-side representation e.g. evaluates \"match('ab/c', 'a*)\"\n// as TRUE, whereas any glob matcher for JS available does false. So we're rewriting it here.\n// See: https://github.com/segmentio/glob/blob/master/glob.go\n\n\nfunction globMatches(pattern, str) {\n  var _a, _b;\n\n  Pattern: while (pattern.length > 0) {\n    var star = void 0;\n    var chunk = void 0;\n    _a = scanChunk(pattern), star = _a.star, chunk = _a.chunk, pattern = _a.pattern;\n\n    if (star && chunk === '') {\n      // Trailing * matches rest of string\n      return true;\n    } // Look for match at current position\n\n\n    var _c = matchChunk(chunk, str),\n        t = _c.t,\n        ok = _c.ok,\n        err = _c.err;\n\n    if (err) {\n      return false;\n    } // If we're the last chunk, make sure we've exhausted the str\n    // otherwise we'll give a false result even if we could still match\n    // using the star\n\n\n    if (ok && (t.length === 0 || pattern.length > 0)) {\n      str = t;\n      continue;\n    }\n\n    if (star) {\n      // Look for match, skipping i+1 bytes.\n      for (var i = 0; i < str.length; i++) {\n        ;\n        _b = matchChunk(chunk, str.slice(i + 1)), t = _b.t, ok = _b.ok, err = _b.err;\n\n        if (ok) {\n          // If we're the last chunk, make sure we exhausted the str.\n          if (pattern.length === 0 && t.length > 0) {\n            continue;\n          }\n\n          str = t;\n          continue Pattern;\n        }\n\n        if (err) {\n          return false;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return str.length === 0;\n}\n\nfunction scanChunk(pattern) {\n  var result = {\n    star: false,\n    chunk: '',\n    pattern: ''\n  };\n\n  while (pattern.length > 0 && pattern[0] === '*') {\n    pattern = pattern.slice(1);\n    result.star = true;\n  }\n\n  var inRange = false;\n  var i;\n\n  Scan: for (i = 0; i < pattern.length; i++) {\n    switch (pattern[i]) {\n      case '\\\\':\n        // Error check handled in matchChunk: bad pattern.\n        if (i + 1 < pattern.length) {\n          i++;\n        }\n\n        break;\n\n      case '[':\n        inRange = true;\n        break;\n\n      case ']':\n        inRange = false;\n        break;\n\n      case '*':\n        if (!inRange) {\n          break Scan;\n        }\n\n    }\n  }\n\n  result.chunk = pattern.slice(0, i);\n  result.pattern = pattern.slice(i);\n  return result;\n} // matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\n\n\nfunction matchChunk(chunk, str) {\n  var _a, _b;\n\n  var result = {\n    t: '',\n    ok: false,\n    err: false\n  };\n\n  while (chunk.length > 0) {\n    if (str.length === 0) {\n      return result;\n    }\n\n    switch (chunk[0]) {\n      case '[':\n        var char = str[0];\n        str = str.slice(1);\n        chunk = chunk.slice(1);\n        var notNegated = true;\n\n        if (chunk.length > 0 && chunk[0] === '^') {\n          notNegated = false;\n          chunk = chunk.slice(1);\n        } // Parse all ranges\n\n\n        var foundMatch = false;\n        var nRange = 0;\n\n        while (true) {\n          if (chunk.length > 0 && chunk[0] === ']' && nRange > 0) {\n            chunk = chunk.slice(1);\n            break;\n          }\n\n          var lo = '';\n          var hi = '';\n          var err = void 0;\n          _a = getEsc(chunk), lo = _a.char, chunk = _a.newChunk, err = _a.err;\n\n          if (err) {\n            return result;\n          }\n\n          hi = lo;\n\n          if (chunk[0] === '-') {\n            ;\n            _b = getEsc(chunk.slice(1)), hi = _b.char, chunk = _b.newChunk, err = _b.err;\n\n            if (err) {\n              return result;\n            }\n          }\n\n          if (lo <= char && char <= hi) {\n            foundMatch = true;\n          }\n\n          nRange++;\n        }\n\n        if (foundMatch !== notNegated) {\n          return result;\n        }\n\n        break;\n\n      case '?':\n        str = str.slice(1);\n        chunk = chunk.slice(1);\n        break;\n\n      case '\\\\':\n        chunk = chunk.slice(1);\n\n        if (chunk.length === 0) {\n          result.err = true;\n          return result;\n        }\n\n      // Fallthrough, missing break intentional.\n\n      default:\n        if (chunk[0] !== str[0]) {\n          return result;\n        }\n\n        str = str.slice(1);\n        chunk = chunk.slice(1);\n    }\n  }\n\n  result.t = str;\n  result.ok = true;\n  result.err = false;\n  return result;\n} // getEsc gets a possibly-escaped character from chunk, for a character class.\n\n\nfunction getEsc(chunk) {\n  var result = {\n    char: '',\n    newChunk: '',\n    err: false\n  };\n\n  if (chunk.length === 0 || chunk[0] === '-' || chunk[0] === ']') {\n    result.err = true;\n    return result;\n  }\n\n  if (chunk[0] === '\\\\') {\n    chunk = chunk.slice(1);\n\n    if (chunk.length === 0) {\n      result.err = true;\n      return result;\n    }\n  } // Unlike Go, JS strings operate on characters instead of bytes.\n  // This is why we aren't copying over the GetRuneFromString stuff.\n\n\n  result.char = chunk[0];\n  result.newChunk = chunk.slice(1);\n\n  if (result.newChunk.length === 0) {\n    result.err = true;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/apple/Sites/react-typescript-template/node_modules/@segment/tsub/src/matchers.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Store from './store'\nimport get from 'dlv'\n\nexport default function matches(event, matcher: Store.Matcher): boolean {\n  if (!matcher) {\n    throw new Error('No matcher supplied!')\n  }\n\n  switch (matcher.type) {\n    case 'all':\n      return all()\n    case 'fql':\n      return fql(matcher.ir, event)\n    default:\n      throw new Error(`Matcher of type ${matcher.type} unsupported.`)\n  }\n}\n\nfunction all(): boolean {\n  return true\n}\n\nfunction fql(ir: Store.Matcher['ir'], event): boolean {\n  if (!ir) {\n    return false\n  }\n\n  try {\n    ir = JSON.parse(ir)\n  } catch (e) {\n    throw new Error(`Failed to JSON.parse FQL intermediate representation \"${ir}\": ${e}`)\n  }\n\n  const result = fqlEvaluate(ir, event)\n  if (typeof result !== 'boolean') {\n    // An error was returned, or a lowercase, typeof, or similar function was run alone. Nothing to evaluate.\n    return false\n  }\n\n  return result\n}\n\n// FQL is 100% type strict in Go. Show no mercy to types which do not comply.\nfunction fqlEvaluate(ir, event) {\n  // If the given ir chunk is not an array, then we should check the single given path or value for literally `true`.\n  if (!Array.isArray(ir)) {\n    return getValue(ir, event) === true\n  }\n\n  // Otherwise, it is a sequence of ordered steps to follow to reach our solution!\n  const item = ir[0]\n  switch (item) {\n    /*** Unary cases ***/\n    // '!' => Invert the result\n    case '!':\n      return !fqlEvaluate(ir[1], event)\n\n    /*** Binary cases ***/\n    // 'or' => Any condition being true returns true\n    case 'or':\n      for (let i = 1; i < ir.length; i++) {\n        if (fqlEvaluate(ir[i], event)) {\n          return true\n        }\n      }\n      return false\n    // 'and' => Any condition being false returns false\n    case 'and':\n      for (let i = 1; i < ir.length; i++) {\n        if (!fqlEvaluate(ir[i], event)) {\n          return false\n        }\n      }\n      return true\n    // Equivalence comparisons\n    case '=':\n    case '!=':\n      return compareItems(getValue(ir[1], event), getValue(ir[2], event), item, event)\n    // Numerical comparisons\n    case '<=':\n    case '<':\n    case '>':\n    case '>=':\n      // Compare the two values with the given operator.\n      return compareNumbers(getValue(ir[1], event), getValue(ir[2], event), item, event)\n\n    /*** Functions ***/\n    // 'contains(str1, str2)' => The first string has a substring of the second string\n    case 'contains':\n      return contains(getValue(ir[1], event), getValue(ir[2], event))\n    // 'match(str, match)' => The given string matches the provided glob matcher\n    case 'match':\n      return match(getValue(ir[1], event), getValue(ir[2], event))\n    // 'lowercase(str)' => Returns a lowercased string, null if the item is not a string\n    case 'lowercase':\n      const target = getValue(ir[1], event)\n      if (typeof target !== 'string') {\n        return null\n      }\n      return target.toLowerCase()\n    // 'typeof(val)' => Returns the FQL type of the value\n    case 'typeof':\n      // TODO: Do we need mapping to allow for universal comparisons? e.g. Object -> JSON, Array -> List, Floats?\n      return typeof getValue(ir[1], event)\n    // 'length(val)' => Returns the length of an array or string, NaN if neither\n    case 'length':\n      return length(getValue(ir[1], event))\n    // If nothing hit, we or the IR messed up somewhere.\n    default:\n      throw new Error(`FQL IR could not evaluate for token: ${item}`)\n  }\n}\n\nfunction getValue(item, event) {\n  // If item is an array, leave it as-is.\n  if (Array.isArray(item)) {\n    return item\n  }\n\n  // If item is an object, it has the form of `{\"value\": VAL}`\n  if (typeof item === 'object') {\n    return item.value\n  }\n\n  // Otherwise, it's an event path, e.g. \"properties.email\"\n  return get(event, item)\n}\n\nfunction compareNumbers(first, second, operator, event): boolean {\n  // Check if it's more IR (such as a length() function)\n  if (isIR(first)) {\n    first = fqlEvaluate(first, event)\n  }\n\n  if (isIR(second)) {\n    second = fqlEvaluate(second, event)\n  }\n\n  if (typeof first !== 'number' || typeof second !== 'number') {\n    return false\n  }\n\n  // Reminder: NaN is not comparable to any other number (including NaN) and will always return false as desired.\n  switch (operator) {\n    // '<=' => The first number is less than or equal to the second.\n    case '<=':\n      return first <= second\n    // '>=' => The first number is greater than or equal to the second\n    case '>=':\n      return first >= second\n    // '<' The first number is less than the second.\n    case '<':\n      return first < second\n    // '>' The first number is greater than the second.\n    case '>':\n      return first > second\n    default:\n      throw new Error(`Invalid operator in compareNumbers: ${operator}`)\n  }\n}\n\nfunction compareItems(first, second, operator, event): boolean {\n  // Check if it's more IR (such as a lowercase() function)\n  if (isIR(first)) {\n    first = fqlEvaluate(first, event)\n  }\n\n  if (isIR(second)) {\n    second = fqlEvaluate(second, event)\n  }\n\n  if (typeof first === 'object' && typeof second === 'object') {\n    first = JSON.stringify(first)\n    second = JSON.stringify(second)\n  }\n\n  // Objects with the exact same contents AND order ARE considered identical. (Don't compare by reference)\n  // Even in Go, this MUST be the same byte order.\n  // e.g. {a: 1, b:2} === {a: 1, b:2} BUT {a:1, b:2} !== {b:2, a:1}\n  // Maybe later we'll use a stable stringifier, but we're matching server-side behavior for now.\n  switch (operator) {\n    // '=' => The two following items are exactly identical\n    case '=':\n      return first === second\n    // '!=' => The two following items are NOT exactly identical.\n    case '!=':\n      return first !== second\n    default:\n      throw new Error(`Invalid operator in compareItems: ${operator}`)\n  }\n}\n\nfunction contains(first, second): boolean {\n  if (typeof first !== 'string' || typeof second !== 'string') {\n    return false\n  }\n\n  return first.indexOf(second) !== -1\n}\n\nfunction match(str, glob): boolean {\n  if (typeof str !== 'string' || typeof glob !== 'string') {\n    return false\n  }\n\n  return globMatches(glob, str)\n}\n\nfunction length(item) {\n  // Match server-side behavior.\n  if (item === null) {\n    return 0\n  }\n\n  // Type-check to avoid returning .length of an object\n  if (!Array.isArray(item) && typeof item !== 'string') {\n    return NaN\n  }\n\n  return item.length\n}\n\n// This is a heuristic technically speaking, but should be close enough. The odds of someone trying to test\n// a func with identical IR notation is pretty low.\nfunction isIR(value): boolean {\n  // TODO: This can be better checked by checking if this is a {\"value\": THIS}\n  if (!Array.isArray(value)) {\n    return false\n  }\n\n  // Function checks\n  if (\n    (value[0] === 'lowercase' || value[0] === 'length' || value[0] === 'typeof') &&\n    value.length === 2\n  ) {\n    return true\n  }\n\n  if ((value[0] === 'contains' || value[0] === 'match') && value.length === 3) {\n    return true\n  }\n\n  return false\n}\n\n// Any reputable glob matcher is designed to work on filesystems and doesn't allow the override of the separator\n// character \"/\". This is problematic since our server-side representation e.g. evaluates \"match('ab/c', 'a*)\"\n// as TRUE, whereas any glob matcher for JS available does false. So we're rewriting it here.\n// See: https://github.com/segmentio/glob/blob/master/glob.go\nfunction globMatches(pattern, str): boolean {\n  Pattern: while (pattern.length > 0) {\n    let star\n    let chunk\n    ;({ star, chunk, pattern } = scanChunk(pattern))\n    if (star && chunk === '') {\n      // Trailing * matches rest of string\n      return true\n    }\n\n    // Look for match at current position\n    let { t, ok, err } = matchChunk(chunk, str)\n    if (err) {\n      return false\n    }\n\n    // If we're the last chunk, make sure we've exhausted the str\n    // otherwise we'll give a false result even if we could still match\n    // using the star\n    if (ok && (t.length === 0 || pattern.length > 0)) {\n      str = t\n      continue\n    }\n\n    if (star) {\n      // Look for match, skipping i+1 bytes.\n      for (let i = 0; i < str.length; i++) {\n        ;({ t, ok, err } = matchChunk(chunk, str.slice(i + 1)))\n        if (ok) {\n          // If we're the last chunk, make sure we exhausted the str.\n          if (pattern.length === 0 && t.length > 0) {\n            continue\n          }\n\n          str = t\n          continue Pattern\n        }\n\n        if (err) {\n          return false\n        }\n      }\n    }\n\n    return false\n  }\n\n  return str.length === 0\n}\n\nfunction scanChunk(pattern): any {\n  const result = {\n    star: false,\n    chunk: '',\n    pattern: '',\n  }\n\n  while (pattern.length > 0 && pattern[0] === '*') {\n    pattern = pattern.slice(1)\n    result.star = true\n  }\n\n  let inRange = false\n  let i\n\n  Scan: for (i = 0; i < pattern.length; i++) {\n    switch (pattern[i]) {\n      case '\\\\':\n        // Error check handled in matchChunk: bad pattern.\n        if (i + 1 < pattern.length) {\n          i++\n        }\n        break\n      case '[':\n        inRange = true\n        break\n      case ']':\n        inRange = false\n        break\n      case '*':\n        if (!inRange) {\n          break Scan\n        }\n    }\n  }\n\n  result.chunk = pattern.slice(0, i)\n  result.pattern = pattern.slice(i)\n  return result\n}\n\n// matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\nfunction matchChunk(chunk, str): any {\n  const result = {\n    t: '',\n    ok: false,\n    err: false,\n  }\n\n  while (chunk.length > 0) {\n    if (str.length === 0) {\n      return result\n    }\n\n    switch (chunk[0]) {\n      case '[':\n        const char = str[0]\n        str = str.slice(1)\n        chunk = chunk.slice(1)\n\n        let notNegated = true\n        if (chunk.length > 0 && chunk[0] === '^') {\n          notNegated = false\n          chunk = chunk.slice(1)\n        }\n\n        // Parse all ranges\n        let foundMatch = false\n        let nRange = 0\n        while (true) {\n          if (chunk.length > 0 && chunk[0] === ']' && nRange > 0) {\n            chunk = chunk.slice(1)\n            break\n          }\n\n          let lo = ''\n          let hi = ''\n          let err\n          ;({ char: lo, newChunk: chunk, err } = getEsc(chunk))\n          if (err) {\n            return result\n          }\n\n          hi = lo\n          if (chunk[0] === '-') {\n            ;({ char: hi, newChunk: chunk, err } = getEsc(chunk.slice(1)))\n            if (err) {\n              return result\n            }\n          }\n\n          if (lo <= char && char <= hi) {\n            foundMatch = true\n          }\n\n          nRange++\n        }\n\n        if (foundMatch !== notNegated) {\n          return result\n        }\n        break\n      case '?':\n        str = str.slice(1)\n        chunk = chunk.slice(1)\n        break\n      case '\\\\':\n        chunk = chunk.slice(1)\n        if (chunk.length === 0) {\n          result.err = true\n          return result\n        }\n      // Fallthrough, missing break intentional.\n      default:\n        if (chunk[0] !== str[0]) {\n          return result\n        }\n        str = str.slice(1)\n        chunk = chunk.slice(1)\n    }\n  }\n\n  result.t = str\n  result.ok = true\n  result.err = false\n  return result\n}\n\n// getEsc gets a possibly-escaped character from chunk, for a character class.\nfunction getEsc(chunk): any {\n  const result = {\n    char: '',\n    newChunk: '',\n    err: false,\n  }\n\n  if (chunk.length === 0 || chunk[0] === '-' || chunk[0] === ']') {\n    result.err = true\n    return result\n  }\n\n  if (chunk[0] === '\\\\') {\n    chunk = chunk.slice(1)\n    if (chunk.length === 0) {\n      result.err = true\n      return result\n    }\n  }\n\n  // Unlike Go, JS strings operate on characters instead of bytes.\n  // This is why we aren't copying over the GetRuneFromString stuff.\n  result.char = chunk[0]\n  result.newChunk = chunk.slice(1)\n  if (result.newChunk.length === 0) {\n    result.err = true\n  }\n\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}