{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar md5_1 = __importDefault(require(\"tiny-hashes/md5\"));\n\nvar dlv_1 = __importDefault(require(\"dlv\"));\n\nvar math_base_special_ldexp_1 = __importDefault(require(\"@stdlib/math-base-special-ldexp\"));\n\nvar dset_1 = require(\"dset\");\n\nvar unset_1 = require(\"./unset\");\n\nfunction transform(payload, transformers) {\n  var transformedPayload = payload;\n\n  for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n    var transformer = transformers_1[_i];\n\n    switch (transformer.type) {\n      case 'drop':\n        return null;\n\n      case 'drop_properties':\n        dropProperties(transformedPayload, transformer.config);\n        break;\n\n      case 'allow_properties':\n        allowProperties(transformedPayload, transformer.config);\n        break;\n\n      case 'sample_event':\n        if (sampleEvent(transformedPayload, transformer.config)) {\n          break;\n        }\n\n        return null;\n\n      case 'map_properties':\n        mapProperties(transformedPayload, transformer.config);\n        break;\n\n      case 'hash_properties':\n        // Not yet supported, but don't throw an error. Just ignore.\n        break;\n\n      default:\n        throw new Error(\"Transformer of type \\\"\".concat(transformer.type, \"\\\" is unsupported.\"));\n    }\n  }\n\n  return transformedPayload;\n}\n\nexports.default = transform; // dropProperties removes all specified props from the object.\n\nfunction dropProperties(payload, config) {\n  for (var key in config.drop) {\n    if (!config.drop.hasOwnProperty(key)) {\n      continue;\n    } // If key is empty, it refers to the top-level object.\n\n\n    var field = key === '' ? payload : (0, dlv_1.default)(payload, key); // Can only drop props off of arrays and objects.\n\n    if (typeof field !== 'object' || field === null) {\n      continue;\n    }\n\n    for (var _i = 0, _a = config.drop[key]; _i < _a.length; _i++) {\n      var target = _a[_i];\n      delete field[target];\n    }\n  }\n} // allowProperties ONLY allows the specific targets within the keys. (e.g. \"a.foo\": [\"bar\", \"baz\"]\n// on {a: {foo: {bar: 1, baz: 2}, other: 3}} will not have any drops, as it only looks inside a.foo\n\n\nfunction allowProperties(payload, config) {\n  for (var key in config.allow) {\n    if (!config.allow.hasOwnProperty(key)) {\n      continue;\n    } // If key is empty, it refers to the top-level object.\n\n\n    var field = key === '' ? payload : (0, dlv_1.default)(payload, key); // Can only drop props off of arrays and objects.\n\n    if (typeof field !== 'object' || field === null) {\n      continue;\n    } // Execution order fortunately doesn't really matter (e.g. if someone filtered off of foo.bar, then foo.bar.baz)\n    // except for micro-optimization.\n\n\n    for (var k in field) {\n      if (!field.hasOwnProperty(k)) {\n        continue;\n      }\n\n      if (config.allow[key].indexOf(k) === -1) {\n        delete field[k];\n      }\n    }\n  }\n}\n\nfunction mapProperties(payload, config) {\n  // Some configs might try to modify or read from a field multiple times. We will only ever read\n  // values as they were before any modifications began. Thus, if you try to override e.g.\n  // {a: {b: 1}} with set(a, 'b', 2) (which results in {a: {b: 2}}) and then try to copy a.b into\n  // a.c, you will get {a: {b: 2, c:1}} and NOT {a: {b:2, c:2}}. This prevents map evaluation\n  // order from mattering, and === what server-side does.\n  // See: https://github.com/segmentio/tsub/blob/661695a63b60b90471796e667458f076af788c19/transformers/map_properties.go#L179-L200\n  var initialPayload = JSON.parse(JSON.stringify(payload));\n\n  for (var key in config.map) {\n    if (!config.map.hasOwnProperty(key)) {\n      continue;\n    }\n\n    var actionMap = config.map[key]; // Can't manipulate non-objects. Check that the parent is one. Strip the last .field\n    // from the string.\n\n    var splitKey = key.split('.');\n    var parent_1 = void 0;\n\n    if (splitKey.length > 1) {\n      splitKey.pop();\n      parent_1 = (0, dlv_1.default)(initialPayload, splitKey.join('.'));\n    } else {\n      parent_1 = payload;\n    }\n\n    if (typeof parent_1 !== 'object') {\n      continue;\n    } // These actions are exclusive to each other.\n\n\n    if (actionMap.copy) {\n      var valueToCopy = (0, dlv_1.default)(initialPayload, actionMap.copy);\n\n      if (valueToCopy !== undefined) {\n        (0, dset_1.dset)(payload, key, valueToCopy);\n      }\n    } else if (actionMap.move) {\n      var valueToMove = (0, dlv_1.default)(initialPayload, actionMap.move);\n\n      if (valueToMove !== undefined) {\n        (0, dset_1.dset)(payload, key, valueToMove);\n      }\n\n      (0, unset_1.unset)(payload, actionMap.move);\n    } // Have to check only if property exists, as null, undefined, and other vals could be explicitly set.\n    else if (actionMap.hasOwnProperty('set')) {\n      (0, dset_1.dset)(payload, key, actionMap.set);\n    } // to_string is not exclusive and can be paired with other actions. Final action.\n\n\n    if (actionMap.to_string) {\n      var valueToString = (0, dlv_1.default)(payload, key); // Do not string arrays and objects. Do not double-encode strings.\n\n      if (typeof valueToString === 'string' || typeof valueToString === 'object' && valueToString !== null) {\n        continue;\n      } // TODO: Check stringifier in Golang for parity.\n\n\n      if (valueToString !== undefined) {\n        (0, dset_1.dset)(payload, key, JSON.stringify(valueToString));\n      } else {\n        // TODO: Check this behavior.\n        (0, dset_1.dset)(payload, key, 'undefined');\n      }\n    }\n  }\n}\n\nfunction sampleEvent(payload, config) {\n  if (config.sample.percent <= 0) {\n    return false;\n  } else if (config.sample.percent >= 1) {\n    return true;\n  } // If we're not filtering deterministically, just use raw percentage.\n\n\n  if (!config.sample.path) {\n    return samplePercent(config.sample.percent);\n  } // Otherwise, use a deterministic hash.\n\n\n  return sampleConsistentPercent(payload, config);\n}\n\nfunction samplePercent(percent) {\n  // Math.random returns [0, 1) => 0.0<>0.9999...\n  return Math.random() <= percent;\n} // sampleConsistentPercent converts an input string of bytes into a consistent uniform\n// continuous distribution of [0.0, 1.0]. This is based on\n// http://mumble.net/~campbell/tmp/random_real.c, but using the digest\n// result of the input value as the random information.\n// IMPORTANT - This function needs to === the Golang implementation to ensure that the two return the same vals!\n// See: https://github.com/segmentio/sampler/blob/65cb04132305a04fcd4bcaef67d57fbe40c30241/sampler.go#L13-L38\n// Since AJS supports IE9+ (typed arrays were introduced in IE10) we're doing some manual array math.\n// This could be done directly with strings, but arrays are easier to reason about/have better function support.\n\n\nfunction sampleConsistentPercent(payload, config) {\n  var field = (0, dlv_1.default)(payload, config.sample.path); // Operate off of JSON bytes. TODO: Validate all type behavior, esp. strings.\n\n  var digest = (0, md5_1.default)(JSON.stringify(field));\n  var exponent = -64; // Manually maintain 64-bit int as an array.\n\n  var significand = []; // Left-shift and OR for first 8 bytes of digest. (8 bytes * 8 = 64 bits)\n\n  consumeDigest(digest.slice(0, 8), significand);\n  var leadingZeros = 0;\n\n  for (var i = 0; i < 64; i++) {\n    if (significand[i] === 1) {\n      break;\n    }\n\n    leadingZeros++;\n  }\n\n  if (leadingZeros !== 0) {\n    // Use the last 8 bytes of the digest, same as before.\n    var val = [];\n    consumeDigest(digest.slice(9, 16), val);\n    exponent -= leadingZeros; // Left-shift away leading zeros in significand.\n\n    significand.splice(0, leadingZeros); // Right-shift val by 64 minus leading zeros and push into significand.\n\n    val.splice(64 - leadingZeros);\n    significand = significand.concat(val);\n  } // Flip 64th bit\n\n\n  significand[63] = significand[63] === 0 ? 1 : 0; // Convert our manual binary into a JS num (binary arr => binary string => psuedo-int) and run the ldexp!\n\n  return (0, math_base_special_ldexp_1.default)(parseInt(significand.join(''), 2), exponent) < config.sample.percent;\n} // Array byte filler helper\n\n\nfunction consumeDigest(digest, arr) {\n  for (var i = 0; i < 8; i++) {\n    var remainder = digest[i];\n\n    for (var binary = 128; binary >= 1; binary /= 2) {\n      if (remainder - binary >= 0) {\n        remainder -= binary;\n        arr.push(1);\n      } else {\n        arr.push(0);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/apple/Sites/react-typescript-template/node_modules/@segment/tsub/src/transformers.ts"],"names":[],"mappings":"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","sourcesContent":["import { Transformer } from './store'\nimport MD5 from 'tiny-hashes/md5'\nimport get from 'dlv'\nimport ldexp from '@stdlib/math-base-special-ldexp'\nimport { dset } from 'dset';\nimport { unset } from './unset'\n\nexport interface TransformerConfig {\n  allow?: Record<string, string[]>\n  drop?: Record<string, string[]>\n  sample?: TransformerConfigSample\n  map?: Record<string, TransformerConfigMap>\n}\n\nexport interface TransformerConfigSample {\n  percent: number\n  path: string\n}\n\nexport interface TransformerConfigMap {\n  set?: any\n  copy?: string\n  move?: string\n  to_string?: boolean\n}\n\nexport default function transform(payload: any, transformers: Transformer[]): any {\n  const transformedPayload: any = payload\n\n  for (const transformer of transformers) {\n    switch (transformer.type) {\n      case 'drop':\n        return null\n      case 'drop_properties':\n        dropProperties(transformedPayload, transformer.config)\n        break\n      case 'allow_properties':\n        allowProperties(transformedPayload, transformer.config)\n        break\n      case 'sample_event':\n        if (sampleEvent(transformedPayload, transformer.config)) {\n          break\n        }\n        return null\n      case 'map_properties':\n        mapProperties(transformedPayload, transformer.config)\n        break\n      case 'hash_properties':\n        // Not yet supported, but don't throw an error. Just ignore.\n        break\n      default:\n        throw new Error(`Transformer of type \"${transformer.type}\" is unsupported.`)\n    }\n  }\n\n  return transformedPayload\n}\n\n// dropProperties removes all specified props from the object.\nfunction dropProperties(payload: any, config: TransformerConfig) {\n  for (const key in config.drop) {\n    if (!config.drop.hasOwnProperty(key)) {\n      continue\n    }\n\n    // If key is empty, it refers to the top-level object.\n    const field = key === '' ? payload : get(payload, key)\n\n    // Can only drop props off of arrays and objects.\n    if (typeof field !== 'object' || field === null) {\n      continue\n    }\n\n    for (const target of config.drop[key]) {\n      delete field[target]\n    }\n  }\n}\n\n// allowProperties ONLY allows the specific targets within the keys. (e.g. \"a.foo\": [\"bar\", \"baz\"]\n// on {a: {foo: {bar: 1, baz: 2}, other: 3}} will not have any drops, as it only looks inside a.foo\nfunction allowProperties(payload: any, config: TransformerConfig) {\n  for (const key in config.allow) {\n    if (!config.allow.hasOwnProperty(key)) {\n      continue\n    }\n\n    // If key is empty, it refers to the top-level object.\n    const field = key === '' ? payload : get(payload, key)\n\n    // Can only drop props off of arrays and objects.\n    if (typeof field !== 'object' || field === null) {\n      continue\n    }\n\n    // Execution order fortunately doesn't really matter (e.g. if someone filtered off of foo.bar, then foo.bar.baz)\n    // except for micro-optimization.\n    for (const k in field) {\n      if (!field.hasOwnProperty(k)) {\n        continue\n      }\n\n      if (config.allow[key].indexOf(k) === -1) {\n        delete field[k]\n      }\n    }\n  }\n}\n\nfunction mapProperties(payload: any, config: TransformerConfig) {\n  // Some configs might try to modify or read from a field multiple times. We will only ever read\n  // values as they were before any modifications began. Thus, if you try to override e.g.\n  // {a: {b: 1}} with set(a, 'b', 2) (which results in {a: {b: 2}}) and then try to copy a.b into\n  // a.c, you will get {a: {b: 2, c:1}} and NOT {a: {b:2, c:2}}. This prevents map evaluation\n  // order from mattering, and === what server-side does.\n  // See: https://github.com/segmentio/tsub/blob/661695a63b60b90471796e667458f076af788c19/transformers/map_properties.go#L179-L200\n  const initialPayload = JSON.parse(JSON.stringify(payload))\n\n  for (const key in config.map) {\n    if (!config.map.hasOwnProperty(key)) {\n      continue\n    }\n\n    const actionMap: TransformerConfigMap = config.map[key]\n\n    // Can't manipulate non-objects. Check that the parent is one. Strip the last .field\n    // from the string.\n    const splitKey = key.split('.')\n    let parent\n    if (splitKey.length > 1) {\n      splitKey.pop()\n      parent = get(initialPayload, splitKey.join('.'))\n    } else {\n      parent = payload\n    }\n\n    if (typeof parent !== 'object') {\n      continue\n    }\n\n    // These actions are exclusive to each other.\n    if (actionMap.copy) {\n      const valueToCopy = get(initialPayload, actionMap.copy)\n      if (valueToCopy !== undefined) {\n        dset(payload, key, valueToCopy)\n      }\n    } else if (actionMap.move) {\n      const valueToMove = get(initialPayload, actionMap.move)\n      if (valueToMove !== undefined) {\n        dset(payload, key, valueToMove)\n      }\n\n      unset(payload, actionMap.move)\n    }\n    // Have to check only if property exists, as null, undefined, and other vals could be explicitly set.\n    else if (actionMap.hasOwnProperty('set')) {\n      dset(payload, key, actionMap.set)\n    }\n\n    // to_string is not exclusive and can be paired with other actions. Final action.\n    if (actionMap.to_string) {\n      const valueToString = get(payload, key)\n\n      // Do not string arrays and objects. Do not double-encode strings.\n      if (\n        typeof valueToString === 'string' ||\n        (typeof valueToString === 'object' && valueToString !== null)\n      ) {\n        continue\n      }\n\n      // TODO: Check stringifier in Golang for parity.\n      if (valueToString !== undefined) {\n        dset(payload, key, JSON.stringify(valueToString))\n      } else {\n        // TODO: Check this behavior.\n        dset(payload, key, 'undefined')\n      }\n    }\n  }\n}\n\nfunction sampleEvent(payload: any, config: TransformerConfig): boolean {\n  if (config.sample.percent <= 0) {\n    return false\n  } else if (config.sample.percent >= 1) {\n    return true\n  }\n\n  // If we're not filtering deterministically, just use raw percentage.\n  if (!config.sample.path) {\n    return samplePercent(config.sample.percent)\n  }\n\n  // Otherwise, use a deterministic hash.\n  return sampleConsistentPercent(payload, config)\n}\n\nfunction samplePercent(percent: number): boolean {\n  // Math.random returns [0, 1) => 0.0<>0.9999...\n  return Math.random() <= percent\n}\n\n// sampleConsistentPercent converts an input string of bytes into a consistent uniform\n// continuous distribution of [0.0, 1.0]. This is based on\n// http://mumble.net/~campbell/tmp/random_real.c, but using the digest\n// result of the input value as the random information.\n\n// IMPORTANT - This function needs to === the Golang implementation to ensure that the two return the same vals!\n// See: https://github.com/segmentio/sampler/blob/65cb04132305a04fcd4bcaef67d57fbe40c30241/sampler.go#L13-L38\n\n// Since AJS supports IE9+ (typed arrays were introduced in IE10) we're doing some manual array math.\n// This could be done directly with strings, but arrays are easier to reason about/have better function support.\nfunction sampleConsistentPercent(payload: any, config: TransformerConfig): boolean {\n  const field = get(payload, config.sample.path)\n\n  // Operate off of JSON bytes. TODO: Validate all type behavior, esp. strings.\n  const digest: number[] = MD5(JSON.stringify(field))\n  let exponent = -64\n\n  // Manually maintain 64-bit int as an array.\n  let significand: number[] = []\n\n  // Left-shift and OR for first 8 bytes of digest. (8 bytes * 8 = 64 bits)\n  consumeDigest(digest.slice(0, 8), significand)\n\n  let leadingZeros = 0\n  for (let i = 0; i < 64; i++) {\n    if (significand[i] === 1) {\n      break\n    }\n\n    leadingZeros++\n  }\n\n  if (leadingZeros !== 0) {\n    // Use the last 8 bytes of the digest, same as before.\n    const val: number[] = []\n    consumeDigest(digest.slice(9, 16), val)\n\n    exponent -= leadingZeros\n    // Left-shift away leading zeros in significand.\n    significand.splice(0, leadingZeros)\n\n    // Right-shift val by 64 minus leading zeros and push into significand.\n    val.splice(64 - leadingZeros)\n    significand = significand.concat(val)\n  }\n\n  // Flip 64th bit\n  significand[63] = significand[63] === 0 ? 1 : 0\n\n  // Convert our manual binary into a JS num (binary arr => binary string => psuedo-int) and run the ldexp!\n  return ldexp(parseInt(significand.join(''), 2), exponent) < config.sample.percent\n}\n\n// Array byte filler helper\nfunction consumeDigest(digest: number[], arr: number[]) {\n  for (let i = 0; i < 8; i++) {\n    let remainder = digest[i]\n    for (let binary = 128; binary >= 1; binary /= 2) {\n      if (remainder - binary >= 0) {\n        remainder -= binary\n        arr.push(1)\n      } else {\n        arr.push(0)\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}