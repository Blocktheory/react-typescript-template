{"ast":null,"code":"import { __assign, __extends, __spreadArray } from \"tslib\";\nimport { PriorityQueue } from '.';\nimport { Context } from '../../core/context';\nimport { isBrowser } from '../../core/environment';\nvar loc = {\n  getItem: function () {},\n  setItem: function () {},\n  removeItem: function () {}\n};\n\ntry {\n  loc = isBrowser() && window.localStorage ? window.localStorage : loc;\n} catch (err) {\n  console.warn('Unable to access localStorage', err);\n}\n\nfunction persisted(key) {\n  var items = loc.getItem(key);\n  return (items ? JSON.parse(items) : []).map(function (p) {\n    return new Context(p.event, p.id);\n  });\n}\n\nfunction persistItems(key, items) {\n  var existing = persisted(key);\n\n  var all = __spreadArray(__spreadArray([], items, true), existing, true);\n\n  var merged = all.reduce(function (acc, item) {\n    var _a;\n\n    return __assign(__assign({}, acc), (_a = {}, _a[item.id] = item, _a));\n  }, {});\n  loc.setItem(key, JSON.stringify(Object.values(merged)));\n}\n\nfunction seen(key) {\n  var stored = loc.getItem(key);\n  return stored ? JSON.parse(stored) : {};\n}\n\nfunction persistSeen(key, memory) {\n  var stored = seen(key);\n  loc.setItem(key, JSON.stringify(__assign(__assign({}, stored), memory)));\n}\n\nfunction remove(key) {\n  loc.removeItem(key);\n}\n\nvar now = function () {\n  return new Date().getTime();\n};\n\nfunction mutex(key, onUnlock, attempt) {\n  if (attempt === void 0) {\n    attempt = 0;\n  }\n\n  var lockTimeout = 50;\n  var lockKey = \"persisted-queue:v1:\".concat(key, \":lock\");\n\n  var expired = function (lock) {\n    return new Date().getTime() > lock;\n  };\n\n  var rawLock = loc.getItem(lockKey);\n  var lock = rawLock ? JSON.parse(rawLock) : null;\n  var allowed = lock === null || expired(lock);\n\n  if (allowed) {\n    loc.setItem(lockKey, JSON.stringify(now() + lockTimeout));\n    onUnlock();\n    loc.removeItem(lockKey);\n    return;\n  }\n\n  if (!allowed && attempt < 3) {\n    setTimeout(function () {\n      mutex(key, onUnlock, attempt + 1);\n    }, lockTimeout);\n  } else {\n    console.error('Unable to retrieve lock');\n  }\n}\n\nvar PersistedPriorityQueue =\n/** @class */\nfunction (_super) {\n  __extends(PersistedPriorityQueue, _super);\n\n  function PersistedPriorityQueue(maxAttempts, key) {\n    var _this = _super.call(this, maxAttempts, []) || this;\n\n    var itemsKey = \"persisted-queue:v1:\".concat(key, \":items\");\n    var seenKey = \"persisted-queue:v1:\".concat(key, \":seen\");\n    var saved = [];\n    var lastSeen = {};\n    mutex(key, function () {\n      try {\n        saved = persisted(itemsKey);\n        lastSeen = seen(seenKey);\n        remove(itemsKey);\n        remove(seenKey);\n        _this.queue = __spreadArray(__spreadArray([], saved, true), _this.queue, true);\n        _this.seen = __assign(__assign({}, lastSeen), _this.seen);\n      } catch (err) {\n        console.error(err);\n      }\n    });\n    window.addEventListener('beforeunload', function () {\n      if (_this.todo > 0) {\n        var items_1 = __spreadArray(__spreadArray([], _this.queue, true), _this.future, true);\n\n        try {\n          mutex(key, function () {\n            persistItems(itemsKey, items_1);\n            persistSeen(seenKey, _this.seen);\n          });\n        } catch (err) {\n          console.error(err);\n        }\n      }\n    });\n    return _this;\n  }\n\n  return PersistedPriorityQueue;\n}(PriorityQueue);\n\nexport { PersistedPriorityQueue };","map":{"version":3,"sources":["/Users/apple/Sites/react-typescript-template/node_modules/@segment/analytics-next/src/lib/priority-queue/persisted.ts"],"names":[],"mappings":"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","sourcesContent":["import { PriorityQueue } from '.'\nimport { Context, SerializedContext } from '../../core/context'\nimport { isBrowser } from '../../core/environment'\n\nlet loc:\n  | Storage\n  | { getItem: () => void; setItem: () => void; removeItem: () => void } = {\n  getItem() {},\n  setItem() {},\n  removeItem() {},\n}\n\ntry {\n  loc = isBrowser() && window.localStorage ? window.localStorage : loc\n} catch (err) {\n  console.warn('Unable to access localStorage', err)\n}\n\nfunction persisted(key: string): Context[] {\n  const items = loc.getItem(key)\n  return (items ? JSON.parse(items) : []).map(\n    (p: SerializedContext) => new Context(p.event, p.id)\n  )\n}\n\nfunction persistItems(key: string, items: Context[]): void {\n  const existing = persisted(key)\n  const all = [...items, ...existing]\n\n  const merged = all.reduce((acc, item) => {\n    return {\n      ...acc,\n      [item.id]: item,\n    }\n  }, {} as Record<string, Context>)\n\n  loc.setItem(key, JSON.stringify(Object.values(merged)))\n}\n\nfunction seen(key: string): Record<string, number> {\n  const stored = loc.getItem(key)\n  return stored ? JSON.parse(stored) : {}\n}\n\nfunction persistSeen(key: string, memory: Record<string, number>): void {\n  const stored = seen(key)\n\n  loc.setItem(\n    key,\n    JSON.stringify({\n      ...stored,\n      ...memory,\n    })\n  )\n}\n\nfunction remove(key: string): void {\n  loc.removeItem(key)\n}\n\nconst now = (): number => new Date().getTime()\n\nfunction mutex(key: string, onUnlock: Function, attempt = 0): void {\n  const lockTimeout = 50\n  const lockKey = `persisted-queue:v1:${key}:lock`\n\n  const expired = (lock: number): boolean => new Date().getTime() > lock\n  const rawLock = loc.getItem(lockKey)\n  const lock = rawLock ? (JSON.parse(rawLock) as number) : null\n\n  const allowed = lock === null || expired(lock)\n  if (allowed) {\n    loc.setItem(lockKey, JSON.stringify(now() + lockTimeout))\n    onUnlock()\n    loc.removeItem(lockKey)\n    return\n  }\n\n  if (!allowed && attempt < 3) {\n    setTimeout(() => {\n      mutex(key, onUnlock, attempt + 1)\n    }, lockTimeout)\n  } else {\n    console.error('Unable to retrieve lock')\n  }\n}\n\nexport class PersistedPriorityQueue extends PriorityQueue<Context> {\n  constructor(maxAttempts: number, key: string) {\n    super(maxAttempts, [])\n\n    const itemsKey = `persisted-queue:v1:${key}:items`\n    const seenKey = `persisted-queue:v1:${key}:seen`\n\n    let saved: Context[] = []\n    let lastSeen: Record<string, number> = {}\n\n    mutex(key, () => {\n      try {\n        saved = persisted(itemsKey)\n        lastSeen = seen(seenKey)\n        remove(itemsKey)\n        remove(seenKey)\n\n        this.queue = [...saved, ...this.queue]\n        this.seen = { ...lastSeen, ...this.seen }\n      } catch (err) {\n        console.error(err)\n      }\n    })\n\n    window.addEventListener('beforeunload', () => {\n      if (this.todo > 0) {\n        const items = [...this.queue, ...this.future]\n        try {\n          mutex(key, () => {\n            persistItems(itemsKey, items)\n            persistSeen(seenKey, this.seen)\n          })\n        } catch (err) {\n          console.error(err)\n        }\n      }\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}