{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { isOffline } from '../../core/connection';\nimport { Context } from '../../core/context';\nimport { attempt } from '../../core/queue/delivery';\nimport { pWhile } from '../../lib/p-while';\n\nfunction flushQueue(xt, queue) {\n  return __awaiter(this, void 0, void 0, function () {\n    var failedQueue;\n\n    var _this = this;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          failedQueue = [];\n\n          if (isOffline()) {\n            return [2\n            /*return*/\n            , queue];\n          }\n\n          return [4\n          /*yield*/\n          , pWhile(function () {\n            return queue.length > 0 && !isOffline();\n          }, function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var ctx, result, success;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    ctx = queue.pop();\n\n                    if (!ctx) {\n                      return [2\n                      /*return*/\n                      ];\n                    }\n\n                    return [4\n                    /*yield*/\n                    , attempt(ctx, xt)];\n\n                  case 1:\n                    result = _a.sent();\n                    success = result instanceof Context;\n\n                    if (!success) {\n                      failedQueue.push(ctx);\n                    }\n\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          }) // re-add failed tasks\n          ];\n\n        case 1:\n          _a.sent(); // re-add failed tasks\n\n\n          failedQueue.map(function (failed) {\n            return queue.pushWithBackoff(failed);\n          });\n          return [2\n          /*return*/\n          , queue];\n      }\n    });\n  });\n}\n\nexport function scheduleFlush(flushing, buffer, xt, scheduleFlush) {\n  var _this = this;\n\n  if (flushing) {\n    return;\n  } // eslint-disable-next-line @typescript-eslint/no-misused-promises\n\n\n  setTimeout(function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var isFlushing, newBuffer;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            isFlushing = true;\n            return [4\n            /*yield*/\n            , flushQueue(xt, buffer)];\n\n          case 1:\n            newBuffer = _a.sent();\n            isFlushing = false;\n\n            if (buffer.todo > 0) {\n              scheduleFlush(isFlushing, newBuffer, xt, scheduleFlush);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, Math.random() * 5000);\n}","map":{"version":3,"sources":["/Users/apple/Sites/react-typescript-template/node_modules/@segment/analytics-next/src/plugins/segmentio/schedule-flush.ts"],"names":[],"mappings":";AAAA,SAAS,SAAT,QAA0B,uBAA1B;AACA,SAAS,OAAT,QAAwB,oBAAxB;AAEA,SAAS,OAAT,QAAwB,2BAAxB;AACA,SAAS,MAAT,QAAuB,mBAAvB;;AAGA,SAAe,UAAf,CACE,EADF,EAEE,KAFF,EAE+B;;;;;;;;;AAEvB,UAAA,WAAW,GAAc,EAAzB;;AACN,cAAI,SAAS,EAAb,EAAiB;AACf,mBAAA,CAAA;AAAA;AAAA,cAAO,KAAP,CAAA;AACD;;AAED,iBAAA,CAAA;AAAA;AAAA,YAAM,MAAM,CACV,YAAA;AAAM,mBAAA,KAAK,CAAC,MAAN,GAAe,CAAf,IAAoB,CAAC,SAArB,EAAA;AAAgC,WAD5B,EAEV,YAAA;AAAA,mBAAA,SAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;;;;AACQ,oBAAA,GAAG,GAAG,KAAK,CAAC,GAAN,EAAN;;AACN,wBAAI,CAAC,GAAL,EAAU;AACR,6BAAA,CAAA;AAAA;AAAA,uBAAA;AACD;;AAEc,2BAAA,CAAA;AAAA;AAAA,sBAAM,OAAO,CAAC,GAAD,EAAM,EAAN,CAAb,CAAA;;;AAAT,oBAAA,MAAM,GAAG,EAAA,CAAA,IAAA,EAAT;AACA,oBAAA,OAAO,GAAG,MAAM,YAAY,OAA5B;;AACN,wBAAI,CAAC,OAAL,EAAc;AACZ,sBAAA,WAAW,CAAC,IAAZ,CAAiB,GAAjB;AACD;;;;;;;aAVH,CAAA;AAWC,WAbS,CAAZ,CAeA;AAfA,WAAA;;;AAAA,UAAA,EAAA,CAAA,IAAA,G,CAeA;;;AACA,UAAA,WAAW,CAAC,GAAZ,CAAgB,UAAC,MAAD,EAAO;AAAK,mBAAA,KAAK,CAAC,eAAN,CAAA,MAAA,CAAA;AAA6B,WAAzD;AACA,iBAAA,CAAA;AAAA;AAAA,YAAO,KAAP,CAAA;;;;AACD;;AAED,OAAM,SAAU,aAAV,CACJ,QADI,EAEJ,MAFI,EAGJ,EAHI,EAIJ,aAJI,EAImB;AAJzB,MAAA,KAAA,GAAA,IAAA;;AAME,MAAI,QAAJ,EAAc;AACZ;AACD,GAJsB,CAMvB;;;AACA,EAAA,UAAU,CAAC,YAAA;AAAA,WAAA,SAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;;;;AACL,YAAA,UAAU,GAAG,IAAb;AAEc,mBAAA,CAAA;AAAA;AAAA,cAAM,UAAU,CAAC,EAAD,EAAK,MAAL,CAAhB,CAAA;;;AAAZ,YAAA,SAAS,GAAG,EAAA,CAAA,IAAA,EAAZ;AACN,YAAA,UAAU,GAAG,KAAb;;AAEA,gBAAI,MAAM,CAAC,IAAP,GAAc,CAAlB,EAAqB;AACnB,cAAA,aAAa,CAAC,UAAD,EAAa,SAAb,EAAwB,EAAxB,EAA4B,aAA5B,CAAb;AACD;;;;;;;KARQ,CAAA;AASV,GATS,EASP,IAAI,CAAC,MAAL,KAAgB,IATT,CAAV;AAUD","sourcesContent":["import { isOffline } from '../../core/connection'\nimport { Context } from '../../core/context'\nimport { Plugin } from '../../core/plugin'\nimport { attempt } from '../../core/queue/delivery'\nimport { pWhile } from '../../lib/p-while'\nimport { PriorityQueue } from '../../lib/priority-queue'\n\nasync function flushQueue(\n  xt: Plugin,\n  queue: PriorityQueue<Context>\n): Promise<PriorityQueue<Context>> {\n  const failedQueue: Context[] = []\n  if (isOffline()) {\n    return queue\n  }\n\n  await pWhile(\n    () => queue.length > 0 && !isOffline(),\n    async () => {\n      const ctx = queue.pop()\n      if (!ctx) {\n        return\n      }\n\n      const result = await attempt(ctx, xt)\n      const success = result instanceof Context\n      if (!success) {\n        failedQueue.push(ctx)\n      }\n    }\n  )\n  // re-add failed tasks\n  failedQueue.map((failed) => queue.pushWithBackoff(failed))\n  return queue\n}\n\nexport function scheduleFlush(\n  flushing: boolean,\n  buffer: PriorityQueue<Context>,\n  xt: Plugin,\n  scheduleFlush: Function\n): void {\n  if (flushing) {\n    return\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  setTimeout(async () => {\n    let isFlushing = true\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const newBuffer = await flushQueue(xt, buffer)\n    isFlushing = false\n\n    if (buffer.todo > 0) {\n      scheduleFlush(isFlushing, newBuffer, xt, scheduleFlush)\n    }\n  }, Math.random() * 5000)\n}\n"]},"metadata":{},"sourceType":"module"}