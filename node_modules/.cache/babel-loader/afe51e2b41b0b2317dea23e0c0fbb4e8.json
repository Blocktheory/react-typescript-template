{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { ContextCancelation } from '../../core/context';\nimport { asPromise } from '../../lib/as-promise';\nimport { toFacade } from '../../lib/to-facade';\nexport function applyDestinationMiddleware(destination, evt, middleware) {\n  return __awaiter(this, void 0, void 0, function () {\n    function applyMiddleware(event, fn) {\n      return __awaiter(this, void 0, void 0, function () {\n        var nextCalled, returnedEvent;\n\n        var _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              nextCalled = false;\n              returnedEvent = null;\n              return [4\n              /*yield*/\n              , asPromise(fn({\n                payload: toFacade(event, {\n                  clone: true,\n                  traverse: false\n                }),\n                integration: destination,\n                next: function (evt) {\n                  nextCalled = true;\n\n                  if (evt === null) {\n                    returnedEvent = null;\n                  }\n\n                  if (evt) {\n                    returnedEvent = evt.obj;\n                  }\n                }\n              }))];\n\n            case 1:\n              _b.sent();\n\n              if (!nextCalled && returnedEvent !== null) {\n                returnedEvent = returnedEvent;\n                returnedEvent.integrations = __assign(__assign({}, event.integrations), (_a = {}, _a[destination] = false, _a));\n              }\n\n              return [2\n              /*return*/\n              , returnedEvent];\n          }\n        });\n      });\n    }\n\n    var _i, middleware_1, md, result;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          _i = 0, middleware_1 = middleware;\n          _a.label = 1;\n\n        case 1:\n          if (!(_i < middleware_1.length)) return [3\n          /*break*/\n          , 4];\n          md = middleware_1[_i];\n          return [4\n          /*yield*/\n          , applyMiddleware(evt, md)];\n\n        case 2:\n          result = _a.sent();\n\n          if (result === null) {\n            return [2\n            /*return*/\n            , null];\n          }\n\n          evt = result;\n          _a.label = 3;\n\n        case 3:\n          _i++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 4:\n          return [2\n          /*return*/\n          , evt];\n      }\n    });\n  });\n}\nexport function sourceMiddlewarePlugin(fn, integrations) {\n  function apply(ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var nextCalled;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            nextCalled = false;\n            return [4\n            /*yield*/\n            , asPromise(fn({\n              payload: toFacade(ctx.event, {\n                clone: true,\n                traverse: false\n              }),\n              integrations: integrations !== null && integrations !== void 0 ? integrations : {},\n              next: function (evt) {\n                nextCalled = true;\n\n                if (evt) {\n                  ctx.event = evt.obj;\n                }\n              }\n            }))];\n\n          case 1:\n            _a.sent();\n\n            if (!nextCalled) {\n              throw new ContextCancelation({\n                retry: false,\n                type: 'middleware_cancellation',\n                reason: 'Middleware `next` function skipped'\n              });\n            }\n\n            return [2\n            /*return*/\n            , ctx];\n        }\n      });\n    });\n  }\n\n  return {\n    name: \"Source Middleware \".concat(fn.name),\n    type: 'before',\n    version: '0.1.0',\n    isLoaded: function () {\n      return true;\n    },\n    load: function (ctx) {\n      return Promise.resolve(ctx);\n    },\n    track: apply,\n    page: apply,\n    identify: apply,\n    alias: apply,\n    group: apply\n  };\n}","map":{"version":3,"sources":["/Users/apple/Sites/react-typescript-template/node_modules/@segment/analytics-next/src/plugins/middleware/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Context, ContextCancelation } from '../../core/context'\nimport { SegmentEvent } from '../../core/events'\nimport { Plugin } from '../../core/plugin'\nimport { asPromise } from '../../lib/as-promise'\nimport { SegmentFacade, toFacade } from '../../lib/to-facade'\n\nexport interface MiddlewareParams {\n  payload: SegmentFacade\n\n  integrations?: SegmentEvent['integrations']\n  next: (payload: MiddlewareParams['payload'] | null) => void\n}\n\nexport interface DestinationMiddlewareParams {\n  payload: SegmentFacade\n  integration: string\n  next: (payload: MiddlewareParams['payload'] | null) => void\n}\n\nexport type MiddlewareFunction = (middleware: MiddlewareParams) => void\nexport type DestinationMiddlewareFunction = (\n  middleware: DestinationMiddlewareParams\n) => void\n\nexport async function applyDestinationMiddleware(\n  destination: string,\n  evt: SegmentEvent,\n  middleware: DestinationMiddlewareFunction[]\n): Promise<SegmentEvent | null> {\n  async function applyMiddleware(\n    event: SegmentEvent,\n    fn: DestinationMiddlewareFunction\n  ): Promise<SegmentEvent | null> {\n    let nextCalled = false\n    let returnedEvent: SegmentEvent | null = null\n\n    await asPromise(\n      fn({\n        payload: toFacade(event, {\n          clone: true,\n          traverse: false,\n        }),\n        integration: destination,\n        next(evt) {\n          nextCalled = true\n\n          if (evt === null) {\n            returnedEvent = null\n          }\n\n          if (evt) {\n            returnedEvent = evt.obj\n          }\n        },\n      })\n    )\n\n    if (!nextCalled && returnedEvent !== null) {\n      returnedEvent = returnedEvent as SegmentEvent\n      returnedEvent.integrations = {\n        ...event.integrations,\n        [destination]: false,\n      }\n    }\n\n    return returnedEvent\n  }\n\n  for (const md of middleware) {\n    const result = await applyMiddleware(evt, md)\n    if (result === null) {\n      return null\n    }\n    evt = result\n  }\n\n  return evt\n}\n\nexport function sourceMiddlewarePlugin(\n  fn: MiddlewareFunction,\n  integrations: SegmentEvent['integrations']\n): Plugin {\n  async function apply(ctx: Context): Promise<Context> {\n    let nextCalled = false\n\n    await asPromise(\n      fn({\n        payload: toFacade(ctx.event, {\n          clone: true,\n          traverse: false,\n        }),\n        integrations: integrations ?? {},\n        next(evt) {\n          nextCalled = true\n          if (evt) {\n            ctx.event = evt.obj\n          }\n        },\n      })\n    )\n\n    if (!nextCalled) {\n      throw new ContextCancelation({\n        retry: false,\n        type: 'middleware_cancellation',\n        reason: 'Middleware `next` function skipped',\n      })\n    }\n\n    return ctx\n  }\n\n  return {\n    name: `Source Middleware ${fn.name}`,\n    type: 'before',\n    version: '0.1.0',\n\n    isLoaded: (): boolean => true,\n    load: (ctx): Promise<Context> => Promise.resolve(ctx),\n\n    track: apply,\n    page: apply,\n    identify: apply,\n    alias: apply,\n    group: apply,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}