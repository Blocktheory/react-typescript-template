{"ast":null,"code":"import { asPromise } from '../../lib/as-promise';\nexport function pTimeout(cb, timeout) {\n  return new Promise(function (resolve, reject) {\n    var timeoutId = setTimeout(function () {\n      reject(Error('Promise timed out'));\n    }, timeout);\n    cb.then(function (val) {\n      clearTimeout(timeoutId);\n      return resolve(val);\n    }).catch(reject);\n  });\n}\n\nfunction sleep(timeoutInMs) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, timeoutInMs);\n  });\n}\n/**\n * @param delayTimeout - The amount of time in ms to wait before invoking the callback.\n * @param timeout - The maximum amount of time in ms to allow the callback to run for.\n */\n\n\nexport function invokeCallback(ctx, callback, delayTimeout, timeout) {\n  var cb = function () {\n    try {\n      return asPromise(callback(ctx));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  };\n\n  return sleep(delayTimeout) // pTimeout ensures that the callback can't cause the context to hang\n  .then(function () {\n    return pTimeout(cb(), timeout !== null && timeout !== void 0 ? timeout : 1000);\n  }).catch(function (err) {\n    ctx === null || ctx === void 0 ? void 0 : ctx.log('warn', 'Callback Error', {\n      error: err\n    });\n    ctx === null || ctx === void 0 ? void 0 : ctx.stats.increment('callback_error');\n  }).then(function () {\n    return ctx;\n  });\n}","map":{"version":3,"sources":["/Users/apple/Sites/react-typescript-template/node_modules/@segment/analytics-next/src/core/callback/index.ts"],"names":[],"mappings":"AACA,SAAS,SAAT,QAA0B,sBAA1B;AAGA,OAAM,SAAU,QAAV,CACJ,EADI,EAEJ,OAFI,EAEW;AAEf,SAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AACjC,QAAM,SAAS,GAAG,UAAU,CAAC,YAAA;AAC3B,MAAA,MAAM,CAAC,KAAK,CAAC,mBAAD,CAAN,CAAN;AACD,KAF2B,EAEzB,OAFyB,CAA5B;AAIA,IAAA,EAAE,CAAC,IAAH,CAAQ,UAAC,GAAD,EAAI;AACV,MAAA,YAAY,CAAC,SAAD,CAAZ;AACA,aAAO,OAAO,CAAC,GAAD,CAAd;AACD,KAHD,EAGG,KAHH,CAGS,MAHT;AAID,GATM,CAAP;AAUD;;AAED,SAAS,KAAT,CAAe,WAAf,EAAkC;AAChC,SAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAQ;AAAK,WAAA,UAAU,CAAC,OAAD,EAAV,WAAU,CAAV;AAAgC,GAAzD,CAAP;AACD;AAED;;;AAGG;;;AACH,OAAM,SAAU,cAAV,CACJ,GADI,EAEJ,QAFI,EAGJ,YAHI,EAIJ,OAJI,EAIY;AAEhB,MAAM,EAAE,GAAG,YAAA;AACT,QAAI;AACF,aAAO,SAAS,CAAC,QAAQ,CAAC,GAAD,CAAT,CAAhB;AACD,KAFD,CAEE,OAAO,GAAP,EAAY;AACZ,aAAO,OAAO,CAAC,MAAR,CAAe,GAAf,CAAP;AACD;AACF,GAND;;AAQA,SACE,KAAK,CAAC,YAAD,CAAL,CACE;AADF,GAEG,IAFH,CAEQ,YAAA;AAAM,WAAA,QAAQ,CAAC,EAAE,EAAH,EAAO,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,GAAf,IAAQ,CAAR;AAA+B,GAF7C,EAGG,KAHH,CAGS,UAAC,GAAD,EAAI;AACT,IAAA,GAAG,KAAA,IAAH,IAAA,GAAG,KAAA,KAAA,CAAH,GAAG,KAAA,CAAH,GAAA,GAAG,CAAE,GAAL,CAAS,MAAT,EAAiB,gBAAjB,EAAmC;AAAE,MAAA,KAAK,EAAE;AAAT,KAAnC,CAAA;AACA,IAAA,GAAG,KAAA,IAAH,IAAA,GAAG,KAAA,KAAA,CAAH,GAAG,KAAA,CAAH,GAAA,GAAG,CAAE,KAAL,CAAW,SAAX,CAAqB,gBAArB,CAAA;AACD,GANH,EAOG,IAPH,CAOQ,YAAA;AAAM,WAAA,GAAA;AAAG,GAPjB,CADF;AAUD","sourcesContent":["import { Context } from '../context'\nimport { asPromise } from '../../lib/as-promise'\nimport { Callback } from '../events/interfaces'\n\nexport function pTimeout(\n  cb: Promise<unknown>,\n  timeout: number\n): Promise<unknown> {\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject(Error('Promise timed out'))\n    }, timeout)\n\n    cb.then((val) => {\n      clearTimeout(timeoutId)\n      return resolve(val)\n    }).catch(reject)\n  })\n}\n\nfunction sleep(timeoutInMs: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, timeoutInMs))\n}\n\n/**\n * @param delayTimeout - The amount of time in ms to wait before invoking the callback.\n * @param timeout - The maximum amount of time in ms to allow the callback to run for.\n */\nexport function invokeCallback(\n  ctx: Context,\n  callback: Callback,\n  delayTimeout: number,\n  timeout?: number\n): Promise<Context> {\n  const cb = () => {\n    try {\n      return asPromise(callback(ctx))\n    } catch (err) {\n      return Promise.reject(err)\n    }\n  }\n\n  return (\n    sleep(delayTimeout)\n      // pTimeout ensures that the callback can't cause the context to hang\n      .then(() => pTimeout(cb(), timeout ?? 1000))\n      .catch((err) => {\n        ctx?.log('warn', 'Callback Error', { error: err })\n        ctx?.stats.increment('callback_error')\n      })\n      .then(() => ctx)\n  )\n}\n"]},"metadata":{},"sourceType":"module"}