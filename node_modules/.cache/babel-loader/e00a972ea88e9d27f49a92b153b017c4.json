{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { groupBy } from '../../lib/group-by';\nimport { ON_REMOVE_FROM_FUTURE } from '../../lib/priority-queue';\nimport { PersistedPriorityQueue } from '../../lib/priority-queue/persisted';\nimport { isOnline } from '../connection';\nimport { Context, ContextCancelation } from '../context';\nimport { Emitter } from '@segment/analytics-core';\nimport { createTaskGroup } from '../task/task-group';\nimport { attempt, ensure } from './delivery';\nimport { inspectorHost } from '../inspector';\n\nvar EventQueue =\n/** @class */\nfunction (_super) {\n  __extends(EventQueue, _super);\n\n  function EventQueue(priorityQueue) {\n    var _this = _super.call(this) || this;\n    /**\n     * All event deliveries get suspended until all the tasks in this task group are complete.\n     * For example: a middleware that augments the event object should be loaded safely as a\n     * critical task, this way, event queue will wait for it to be ready before sending events.\n     *\n     * This applies to all the events already in the queue, and the upcoming ones\n     */\n\n\n    _this.criticalTasks = createTaskGroup();\n    _this.plugins = [];\n    _this.failedInitializations = [];\n    _this.flushing = false;\n    _this.queue = priorityQueue !== null && priorityQueue !== void 0 ? priorityQueue : new PersistedPriorityQueue(4, 'event-queue');\n\n    _this.queue.on(ON_REMOVE_FROM_FUTURE, function () {\n      _this.scheduleFlush(0);\n    });\n\n    return _this;\n  }\n\n  EventQueue.prototype.register = function (ctx, plugin, instance) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.resolve(plugin.load(ctx, instance)).then(function () {\n              _this.plugins.push(plugin);\n            }).catch(function (err) {\n              if (plugin.type === 'destination') {\n                _this.failedInitializations.push(plugin.name);\n\n                console.warn(plugin.name, err);\n                ctx.log('warn', 'Failed to load destination', {\n                  plugin: plugin.name,\n                  error: err\n                });\n                return;\n              }\n\n              throw err;\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  EventQueue.prototype.deregister = function (ctx, plugin, instance) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 3,, 4]);\n\n            if (!plugin.unload) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , Promise.resolve(plugin.unload(ctx, instance))];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            this.plugins = this.plugins.filter(function (p) {\n              return p.name !== plugin.name;\n            });\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            ctx.log('warn', 'Failed to unload destination', {\n              plugin: plugin.name,\n              error: e_1\n            });\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  EventQueue.prototype.dispatch = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var willDeliver;\n      return __generator(this, function (_a) {\n        ctx.log('debug', 'Dispatching');\n        ctx.stats.increment('message_dispatched');\n        this.queue.push(ctx);\n        willDeliver = this.subscribeToDelivery(ctx);\n        this.scheduleFlush(0);\n        return [2\n        /*return*/\n        , willDeliver];\n      });\n    });\n  };\n\n  EventQueue.prototype.subscribeToDelivery = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve) {\n          var onDeliver = function (flushed, delivered) {\n            if (flushed.isSame(ctx)) {\n              _this.off('flush', onDeliver);\n\n              if (delivered) {\n                resolve(flushed);\n              } else {\n                resolve(flushed);\n              }\n            }\n          };\n\n          _this.on('flush', onDeliver);\n        })];\n      });\n    });\n  };\n\n  EventQueue.prototype.dispatchSingle = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        ctx.log('debug', 'Dispatching');\n        ctx.stats.increment('message_dispatched');\n        this.queue.updateAttempts(ctx);\n        ctx.attempts = 1;\n        return [2\n        /*return*/\n        , this.deliver(ctx).catch(function (err) {\n          if (err instanceof ContextCancelation && err.retry === false) {\n            ctx.setFailedDelivery({\n              reason: err\n            });\n            return ctx;\n          }\n\n          var accepted = _this.enqueuRetry(err, ctx);\n\n          if (!accepted) {\n            ctx.setFailedDelivery({\n              reason: err\n            });\n            return ctx;\n          }\n\n          return _this.subscribeToDelivery(ctx);\n        })];\n      });\n    });\n  };\n\n  EventQueue.prototype.isEmpty = function () {\n    return this.queue.length === 0;\n  };\n\n  EventQueue.prototype.scheduleFlush = function (timeout) {\n    var _this = this;\n\n    if (timeout === void 0) {\n      timeout = 500;\n    }\n\n    if (this.flushing) {\n      return;\n    }\n\n    this.flushing = true;\n    setTimeout(function () {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _this.flush().then(function () {\n        setTimeout(function () {\n          _this.flushing = false;\n\n          if (_this.queue.length) {\n            _this.scheduleFlush(0);\n          }\n        }, 0);\n      });\n    }, timeout);\n  };\n\n  EventQueue.prototype.deliver = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var start, done, err_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.criticalTasks.done()];\n\n          case 1:\n            _a.sent();\n\n            start = Date.now();\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.flushOne(ctx)];\n\n          case 3:\n            ctx = _a.sent();\n            done = Date.now() - start;\n            ctx.stats.gauge('delivered', done);\n            ctx.log('debug', 'Delivered', ctx.event);\n            return [2\n            /*return*/\n            , ctx];\n\n          case 4:\n            err_1 = _a.sent();\n            ctx.log('error', 'Failed to deliver', err_1);\n            ctx.stats.increment('delivery_failed');\n            throw err_1;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  EventQueue.prototype.enqueuRetry = function (err, ctx) {\n    var notRetriable = err instanceof ContextCancelation && err.retry === false;\n    var retriable = !notRetriable;\n\n    if (retriable) {\n      var accepted = this.queue.pushWithBackoff(ctx);\n      return accepted;\n    }\n\n    return false;\n  };\n\n  EventQueue.prototype.flush = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ctx, err_2, accepted;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.queue.length === 0 || !isOnline()) {\n              return [2\n              /*return*/\n              , []];\n            }\n\n            ctx = this.queue.pop();\n\n            if (!ctx) {\n              return [2\n              /*return*/\n              , []];\n            }\n\n            ctx.attempts = this.queue.getAttempts(ctx);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.deliver(ctx)];\n\n          case 2:\n            ctx = _a.sent();\n            this.emit('flush', ctx, true);\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_2 = _a.sent();\n            accepted = this.enqueuRetry(err_2, ctx);\n\n            if (!accepted) {\n              ctx.setFailedDelivery({\n                reason: err_2\n              });\n              this.emit('flush', ctx, false);\n            }\n\n            return [2\n            /*return*/\n            , []];\n\n          case 4:\n            return [2\n            /*return*/\n            , [ctx]];\n        }\n      });\n    });\n  };\n\n  EventQueue.prototype.isReady = function () {\n    // return this.plugins.every((p) => p.isLoaded())\n    // should we wait for every plugin to load?\n    return true;\n  };\n\n  EventQueue.prototype.availableExtensions = function (denyList) {\n    var available = this.plugins.filter(function (p) {\n      var _a; // Only filter out destination plugins or the Segment.io plugin\n\n\n      if (p.type !== 'destination' && p.name !== 'Segment.io') {\n        return true;\n      } // Explicit integration option takes precedence, `All: false` does not apply to Segment.io\n\n\n      return (_a = denyList[p.name]) !== null && _a !== void 0 ? _a : (p.name === 'Segment.io' ? true : denyList.All) !== false;\n    });\n\n    var _a = groupBy(available, 'type'),\n        _b = _a.before,\n        before = _b === void 0 ? [] : _b,\n        _c = _a.enrichment,\n        enrichment = _c === void 0 ? [] : _c,\n        _d = _a.destination,\n        destination = _d === void 0 ? [] : _d,\n        _e = _a.after,\n        after = _e === void 0 ? [] : _e;\n\n    return {\n      before: before,\n      enrichment: enrichment,\n      destinations: destination,\n      after: after\n    };\n  };\n\n  EventQueue.prototype.flushOne = function (ctx) {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _e, before, enrichment, _i, before_1, beforeWare, temp, _f, enrichment_1, enrichmentWare, temp, _g, destinations, after, afterCalls;\n\n      return __generator(this, function (_h) {\n        switch (_h.label) {\n          case 0:\n            if (!this.isReady()) {\n              throw new Error('Not ready');\n            }\n\n            _e = this.availableExtensions((_a = ctx.event.integrations) !== null && _a !== void 0 ? _a : {}), before = _e.before, enrichment = _e.enrichment;\n            _i = 0, before_1 = before;\n            _h.label = 1;\n\n          case 1:\n            if (!(_i < before_1.length)) return [3\n            /*break*/\n            , 4];\n            beforeWare = before_1[_i];\n            return [4\n            /*yield*/\n            , ensure(ctx, beforeWare)];\n\n          case 2:\n            temp = _h.sent();\n\n            if (temp instanceof Context) {\n              ctx = temp;\n            }\n\n            _h.label = 3;\n\n          case 3:\n            _i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            _f = 0, enrichment_1 = enrichment;\n            _h.label = 5;\n\n          case 5:\n            if (!(_f < enrichment_1.length)) return [3\n            /*break*/\n            , 8];\n            enrichmentWare = enrichment_1[_f];\n            return [4\n            /*yield*/\n            , attempt(ctx, enrichmentWare)];\n\n          case 6:\n            temp = _h.sent();\n\n            if (temp instanceof Context) {\n              ctx = temp;\n            }\n\n            _h.label = 7;\n\n          case 7:\n            _f++;\n            return [3\n            /*break*/\n            , 5];\n\n          case 8:\n            (_b = inspectorHost.enriched) === null || _b === void 0 ? void 0 : _b.call(inspectorHost, ctx);\n            _g = this.availableExtensions((_c = ctx.event.integrations) !== null && _c !== void 0 ? _c : {}), destinations = _g.destinations, after = _g.after;\n            return [4\n            /*yield*/\n            , new Promise(function (resolve, reject) {\n              setTimeout(function () {\n                var attempts = destinations.map(function (destination) {\n                  return attempt(ctx, destination);\n                });\n                Promise.all(attempts).then(resolve).catch(reject);\n              }, 0);\n            })];\n\n          case 9:\n            _h.sent();\n\n            ctx.stats.increment('message_delivered'); // FIXME: Resolve browsers destinations that the event was sent to\n\n            (_d = inspectorHost.delivered) === null || _d === void 0 ? void 0 : _d.call(inspectorHost, ctx, ['segment.io']);\n            afterCalls = after.map(function (after) {\n              return attempt(ctx, after);\n            });\n            return [4\n            /*yield*/\n            , Promise.all(afterCalls)];\n\n          case 10:\n            _h.sent();\n\n            return [2\n            /*return*/\n            , ctx];\n        }\n      });\n    });\n  };\n\n  return EventQueue;\n}(Emitter);\n\nexport { EventQueue };","map":{"version":3,"sources":["/Users/apple/Sites/react-typescript-template/node_modules/@segment/analytics-next/src/core/queue/event-queue.ts"],"names":[],"mappings":"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","sourcesContent":["import { Analytics } from '../analytics'\nimport { groupBy } from '../../lib/group-by'\nimport { ON_REMOVE_FROM_FUTURE, PriorityQueue } from '../../lib/priority-queue'\nimport { PersistedPriorityQueue } from '../../lib/priority-queue/persisted'\nimport { isOnline } from '../connection'\nimport { Context, ContextCancelation } from '../context'\nimport { Emitter } from '@segment/analytics-core'\nimport { Integrations } from '../events'\nimport { Plugin } from '../plugin'\nimport { createTaskGroup, TaskGroup } from '../task/task-group'\nimport { attempt, ensure } from './delivery'\nimport { inspectorHost } from '../inspector'\n\ntype PluginsByType = {\n  before: Plugin[]\n  after: Plugin[]\n  enrichment: Plugin[]\n  destinations: Plugin[]\n}\n\nexport class EventQueue extends Emitter {\n  /**\n   * All event deliveries get suspended until all the tasks in this task group are complete.\n   * For example: a middleware that augments the event object should be loaded safely as a\n   * critical task, this way, event queue will wait for it to be ready before sending events.\n   *\n   * This applies to all the events already in the queue, and the upcoming ones\n   */\n  criticalTasks: TaskGroup = createTaskGroup()\n  queue: PriorityQueue<Context>\n  plugins: Plugin[] = []\n  failedInitializations: string[] = []\n  private flushing = false\n\n  constructor(priorityQueue?: PriorityQueue<Context>) {\n    super()\n    this.queue = priorityQueue ?? new PersistedPriorityQueue(4, 'event-queue')\n    this.queue.on(ON_REMOVE_FROM_FUTURE, () => {\n      this.scheduleFlush(0)\n    })\n  }\n\n  async register(\n    ctx: Context,\n    plugin: Plugin,\n    instance: Analytics\n  ): Promise<void> {\n    await Promise.resolve(plugin.load(ctx, instance))\n      .then(() => {\n        this.plugins.push(plugin)\n      })\n      .catch((err) => {\n        if (plugin.type === 'destination') {\n          this.failedInitializations.push(plugin.name)\n          console.warn(plugin.name, err)\n\n          ctx.log('warn', 'Failed to load destination', {\n            plugin: plugin.name,\n            error: err,\n          })\n\n          return\n        }\n\n        throw err\n      })\n  }\n\n  async deregister(\n    ctx: Context,\n    plugin: Plugin,\n    instance: Analytics\n  ): Promise<void> {\n    try {\n      if (plugin.unload) {\n        await Promise.resolve(plugin.unload(ctx, instance))\n      }\n\n      this.plugins = this.plugins.filter((p) => p.name !== plugin.name)\n    } catch (e) {\n      ctx.log('warn', 'Failed to unload destination', {\n        plugin: plugin.name,\n        error: e,\n      })\n    }\n  }\n\n  async dispatch(ctx: Context): Promise<Context> {\n    ctx.log('debug', 'Dispatching')\n    ctx.stats.increment('message_dispatched')\n\n    this.queue.push(ctx)\n    const willDeliver = this.subscribeToDelivery(ctx)\n    this.scheduleFlush(0)\n    return willDeliver\n  }\n\n  private async subscribeToDelivery(ctx: Context): Promise<Context> {\n    return new Promise((resolve) => {\n      const onDeliver = (flushed: Context, delivered: boolean): void => {\n        if (flushed.isSame(ctx)) {\n          this.off('flush', onDeliver)\n          if (delivered) {\n            resolve(flushed)\n          } else {\n            resolve(flushed)\n          }\n        }\n      }\n\n      this.on('flush', onDeliver)\n    })\n  }\n\n  async dispatchSingle(ctx: Context): Promise<Context> {\n    ctx.log('debug', 'Dispatching')\n    ctx.stats.increment('message_dispatched')\n\n    this.queue.updateAttempts(ctx)\n    ctx.attempts = 1\n\n    return this.deliver(ctx).catch((err) => {\n      if (err instanceof ContextCancelation && err.retry === false) {\n        ctx.setFailedDelivery({ reason: err })\n        return ctx\n      }\n\n      const accepted = this.enqueuRetry(err, ctx)\n      if (!accepted) {\n        ctx.setFailedDelivery({ reason: err })\n        return ctx\n      }\n\n      return this.subscribeToDelivery(ctx)\n    })\n  }\n\n  isEmpty(): boolean {\n    return this.queue.length === 0\n  }\n\n  private scheduleFlush(timeout = 500): void {\n    if (this.flushing) {\n      return\n    }\n\n    this.flushing = true\n\n    setTimeout(() => {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.flush().then(() => {\n        setTimeout(() => {\n          this.flushing = false\n\n          if (this.queue.length) {\n            this.scheduleFlush(0)\n          }\n        }, 0)\n      })\n    }, timeout)\n  }\n\n  private async deliver(ctx: Context): Promise<Context> {\n    await this.criticalTasks.done()\n\n    const start = Date.now()\n    try {\n      ctx = await this.flushOne(ctx)\n      const done = Date.now() - start\n      ctx.stats.gauge('delivered', done)\n      ctx.log('debug', 'Delivered', ctx.event)\n      return ctx\n    } catch (err) {\n      ctx.log('error', 'Failed to deliver', err as object)\n      ctx.stats.increment('delivery_failed')\n      throw err\n    }\n  }\n\n  private enqueuRetry(err: Error, ctx: Context): boolean {\n    const notRetriable =\n      err instanceof ContextCancelation && err.retry === false\n    const retriable = !notRetriable\n\n    if (retriable) {\n      const accepted = this.queue.pushWithBackoff(ctx)\n      return accepted\n    }\n\n    return false\n  }\n\n  async flush(): Promise<Context[]> {\n    if (this.queue.length === 0 || !isOnline()) {\n      return []\n    }\n\n    let ctx = this.queue.pop()\n    if (!ctx) {\n      return []\n    }\n\n    ctx.attempts = this.queue.getAttempts(ctx)\n\n    try {\n      ctx = await this.deliver(ctx)\n      this.emit('flush', ctx, true)\n    } catch (err: any) {\n      const accepted = this.enqueuRetry(err, ctx)\n\n      if (!accepted) {\n        ctx.setFailedDelivery({ reason: err })\n        this.emit('flush', ctx, false)\n      }\n\n      return []\n    }\n\n    return [ctx]\n  }\n\n  private isReady(): boolean {\n    // return this.plugins.every((p) => p.isLoaded())\n    // should we wait for every plugin to load?\n    return true\n  }\n\n  private availableExtensions(denyList: Integrations): PluginsByType {\n    const available = this.plugins.filter((p) => {\n      // Only filter out destination plugins or the Segment.io plugin\n      if (p.type !== 'destination' && p.name !== 'Segment.io') {\n        return true\n      }\n\n      // Explicit integration option takes precedence, `All: false` does not apply to Segment.io\n      return (\n        denyList[p.name] ??\n        (p.name === 'Segment.io' ? true : denyList.All) !== false\n      )\n    })\n\n    const {\n      before = [],\n      enrichment = [],\n      destination = [],\n      after = [],\n    } = groupBy(available, 'type')\n\n    return {\n      before,\n      enrichment,\n      destinations: destination,\n      after,\n    }\n  }\n\n  private async flushOne(ctx: Context): Promise<Context> {\n    if (!this.isReady()) {\n      throw new Error('Not ready')\n    }\n\n    const { before, enrichment } = this.availableExtensions(\n      ctx.event.integrations ?? {}\n    )\n\n    for (const beforeWare of before) {\n      const temp: Context | undefined = await ensure(ctx, beforeWare)\n      if (temp instanceof Context) {\n        ctx = temp\n      }\n    }\n\n    for (const enrichmentWare of enrichment) {\n      const temp = await attempt(ctx, enrichmentWare)\n      if (temp instanceof Context) {\n        ctx = temp\n      }\n    }\n\n    inspectorHost.enriched?.(ctx as any)\n\n    // Enrichment and before plugins can re-arrange the deny list dynamically\n    // so we need to pluck them at the end\n    const { destinations, after } = this.availableExtensions(\n      ctx.event.integrations ?? {}\n    )\n\n    await new Promise((resolve, reject) => {\n      setTimeout(() => {\n        const attempts = destinations.map((destination) =>\n          attempt(ctx, destination)\n        )\n        Promise.all(attempts).then(resolve).catch(reject)\n      }, 0)\n    })\n\n    ctx.stats.increment('message_delivered')\n\n    // FIXME: Resolve browsers destinations that the event was sent to\n    inspectorHost.delivered?.(ctx as any, ['segment.io'])\n\n    const afterCalls = after.map((after) => attempt(ctx, after))\n    await Promise.all(afterCalls)\n\n    return ctx\n  }\n}\n"]},"metadata":{},"sourceType":"module"}