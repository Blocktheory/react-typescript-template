{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { v4 as uuid } from '@lukeed/uuid';\nimport { dset } from 'dset';\nimport md5 from 'spark-md5';\nexport * from './interfaces';\n\nvar EventFactory =\n/** @class */\nfunction () {\n  function EventFactory(user) {\n    this.user = user;\n  }\n\n  EventFactory.prototype.track = function (event, properties, options, globalIntegrations) {\n    return this.normalize(__assign(__assign({}, this.baseEvent()), {\n      event: event,\n      type: 'track',\n      properties: properties,\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    }));\n  };\n\n  EventFactory.prototype.page = function (category, page, properties, options, globalIntegrations) {\n    var _a;\n\n    var event = {\n      type: 'page',\n      properties: __assign({}, properties),\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    };\n\n    if (category !== null) {\n      event.category = category;\n      event.properties = (_a = event.properties) !== null && _a !== void 0 ? _a : {};\n      event.properties.category = category;\n    }\n\n    if (page !== null) {\n      event.name = page;\n    }\n\n    return this.normalize(__assign(__assign({}, this.baseEvent()), event));\n  };\n\n  EventFactory.prototype.screen = function (category, screen, properties, options, globalIntegrations) {\n    var event = {\n      type: 'screen',\n      properties: __assign({}, properties),\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    };\n\n    if (category !== null) {\n      event.category = category;\n    }\n\n    if (screen !== null) {\n      event.name = screen;\n    }\n\n    return this.normalize(__assign(__assign({}, this.baseEvent()), event));\n  };\n\n  EventFactory.prototype.identify = function (userId, traits, options, globalIntegrations) {\n    return this.normalize(__assign(__assign({}, this.baseEvent()), {\n      type: 'identify',\n      userId: userId,\n      traits: traits,\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    }));\n  };\n\n  EventFactory.prototype.group = function (groupId, traits, options, globalIntegrations) {\n    return this.normalize(__assign(__assign({}, this.baseEvent()), {\n      type: 'group',\n      traits: traits,\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations),\n      groupId: groupId\n    }));\n  };\n\n  EventFactory.prototype.alias = function (to, from, options, globalIntegrations) {\n    var base = {\n      userId: to,\n      type: 'alias',\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    };\n\n    if (from !== null) {\n      base.previousId = from;\n    }\n\n    if (to === undefined) {\n      return this.normalize(__assign(__assign({}, base), this.baseEvent()));\n    }\n\n    return this.normalize(__assign(__assign({}, this.baseEvent()), base));\n  };\n\n  EventFactory.prototype.baseEvent = function () {\n    var base = {\n      integrations: {},\n      options: {}\n    };\n    var user = this.user;\n\n    if (user.id()) {\n      base.userId = user.id();\n    }\n\n    if (user.anonymousId()) {\n      base.anonymousId = user.anonymousId();\n    }\n\n    return base;\n  };\n  /**\n   * Builds the context part of an event based on \"foreign\" keys that\n   * are provided in the `Options` parameter for an Event\n   */\n\n\n  EventFactory.prototype.context = function (event) {\n    var _a, _b, _c;\n\n    var optionsKeys = ['integrations', 'anonymousId', 'timestamp', 'userId'];\n    var options = (_a = event.options) !== null && _a !== void 0 ? _a : {};\n    delete options['integrations'];\n    var providedOptionsKeys = Object.keys(options);\n    var context = (_c = (_b = event.options) === null || _b === void 0 ? void 0 : _b.context) !== null && _c !== void 0 ? _c : {};\n    var overrides = {};\n    providedOptionsKeys.forEach(function (key) {\n      if (key === 'context') {\n        return;\n      }\n\n      if (optionsKeys.includes(key)) {\n        dset(overrides, key, options[key]);\n      } else {\n        dset(context, key, options[key]);\n      }\n    });\n    return [context, overrides];\n  };\n\n  EventFactory.prototype.normalize = function (event) {\n    var _a, _b;\n\n    var integrationBooleans = Object.keys((_a = event.integrations) !== null && _a !== void 0 ? _a : {}).reduce(function (integrationNames, name) {\n      var _a;\n\n      var _b;\n\n      return __assign(__assign({}, integrationNames), (_a = {}, _a[name] = Boolean((_b = event.integrations) === null || _b === void 0 ? void 0 : _b[name]), _a));\n    }, {}); // This is pretty trippy, but here's what's going on:\n    // - a) We don't pass initial integration options as part of the event, only if they're true or false\n    // - b) We do accept per integration overrides (like integrations.Amplitude.sessionId) at the event level\n    // Hence the need to convert base integration options to booleans, but maintain per event integration overrides\n\n    var allIntegrations = __assign(__assign({}, integrationBooleans), (_b = event.options) === null || _b === void 0 ? void 0 : _b.integrations);\n\n    var _c = this.context(event),\n        context = _c[0],\n        overrides = _c[1];\n\n    var options = event.options,\n        rest = __rest(event, [\"options\"]);\n\n    var body = __assign(__assign(__assign({\n      timestamp: new Date()\n    }, rest), {\n      context: context,\n      integrations: allIntegrations\n    }), overrides);\n\n    var messageId = 'ajs-next-' + md5.hash(JSON.stringify(body) + uuid());\n\n    var evt = __assign(__assign({}, body), {\n      messageId: messageId\n    });\n\n    return evt;\n  };\n\n  return EventFactory;\n}();\n\nexport { EventFactory };","map":{"version":3,"sources":["/Users/apple/Sites/react-typescript-template/node_modules/@segment/analytics-next/src/core/events/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { v4 as uuid } from '@lukeed/uuid'\nimport { dset } from 'dset'\nimport { ID, User } from '../user'\nimport {\n  Options,\n  Integrations,\n  EventProperties,\n  Traits,\n  SegmentEvent,\n} from './interfaces'\nimport md5 from 'spark-md5'\n\nexport * from './interfaces'\n\nexport class EventFactory {\n  user: User\n\n  constructor(user: User) {\n    this.user = user\n  }\n\n  track(\n    event: string,\n    properties?: EventProperties,\n    options?: Options,\n    globalIntegrations?: Integrations\n  ): SegmentEvent {\n    return this.normalize({\n      ...this.baseEvent(),\n      event,\n      type: 'track' as const,\n      properties,\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    })\n  }\n\n  page(\n    category: string | null,\n    page: string | null,\n    properties?: EventProperties,\n    options?: Options,\n    globalIntegrations?: Integrations\n  ): SegmentEvent {\n    const event: Partial<SegmentEvent> = {\n      type: 'page' as const,\n      properties: { ...properties },\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    }\n\n    if (category !== null) {\n      event.category = category\n      event.properties = event.properties ?? {}\n      event.properties.category = category\n    }\n\n    if (page !== null) {\n      event.name = page\n    }\n\n    return this.normalize({\n      ...this.baseEvent(),\n      ...event,\n    } as SegmentEvent)\n  }\n\n  screen(\n    category: string | null,\n    screen: string | null,\n    properties?: EventProperties,\n    options?: Options,\n    globalIntegrations?: Integrations\n  ): SegmentEvent {\n    const event: Partial<SegmentEvent> = {\n      type: 'screen' as const,\n      properties: { ...properties },\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    }\n\n    if (category !== null) {\n      event.category = category\n    }\n\n    if (screen !== null) {\n      event.name = screen\n    }\n\n    return this.normalize({\n      ...this.baseEvent(),\n      ...event,\n    } as SegmentEvent)\n  }\n\n  identify(\n    userId: ID,\n    traits?: Traits,\n    options?: Options,\n    globalIntegrations?: Integrations\n  ): SegmentEvent {\n    return this.normalize({\n      ...this.baseEvent(),\n      type: 'identify' as const,\n      userId,\n      traits,\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    })\n  }\n\n  group(\n    groupId: ID,\n    traits?: Traits,\n    options?: Options,\n    globalIntegrations?: Integrations\n  ): SegmentEvent {\n    return this.normalize({\n      ...this.baseEvent(),\n      type: 'group' as const,\n      traits,\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n      groupId,\n    })\n  }\n\n  alias(\n    to: string,\n    from: string | null,\n    options?: Options,\n    globalIntegrations?: Integrations\n  ): SegmentEvent {\n    const base: Partial<SegmentEvent> = {\n      userId: to,\n      type: 'alias' as const,\n      options: { ...options },\n      integrations: { ...globalIntegrations },\n    }\n\n    if (from !== null) {\n      base.previousId = from\n    }\n\n    if (to === undefined) {\n      return this.normalize({\n        ...base,\n        ...this.baseEvent(),\n      } as SegmentEvent)\n    }\n\n    return this.normalize({\n      ...this.baseEvent(),\n      ...base,\n    } as SegmentEvent)\n  }\n\n  private baseEvent(): Partial<SegmentEvent> {\n    const base: Partial<SegmentEvent> = {\n      integrations: {},\n      options: {},\n    }\n\n    const user = this.user\n\n    if (user.id()) {\n      base.userId = user.id()\n    }\n\n    if (user.anonymousId()) {\n      base.anonymousId = user.anonymousId()\n    }\n\n    return base\n  }\n\n  /**\n   * Builds the context part of an event based on \"foreign\" keys that\n   * are provided in the `Options` parameter for an Event\n   */\n  private context(event: SegmentEvent): [object, object] {\n    const optionsKeys = ['integrations', 'anonymousId', 'timestamp', 'userId']\n\n    const options = event.options ?? {}\n    delete options['integrations']\n\n    const providedOptionsKeys = Object.keys(options)\n\n    const context = event.options?.context ?? {}\n    const overrides = {}\n\n    providedOptionsKeys.forEach((key) => {\n      if (key === 'context') {\n        return\n      }\n\n      if (optionsKeys.includes(key)) {\n        dset(overrides, key, options[key])\n      } else {\n        dset(context, key, options[key])\n      }\n    })\n\n    return [context, overrides]\n  }\n\n  public normalize(event: SegmentEvent): SegmentEvent {\n    const integrationBooleans = Object.keys(event.integrations ?? {}).reduce(\n      (integrationNames, name) => {\n        return {\n          ...integrationNames,\n          [name]: Boolean(event.integrations?.[name]),\n        }\n      },\n      {} as Record<string, boolean>\n    )\n\n    // This is pretty trippy, but here's what's going on:\n    // - a) We don't pass initial integration options as part of the event, only if they're true or false\n    // - b) We do accept per integration overrides (like integrations.Amplitude.sessionId) at the event level\n    // Hence the need to convert base integration options to booleans, but maintain per event integration overrides\n    const allIntegrations = {\n      // Base config integrations object as booleans\n      ...integrationBooleans,\n\n      // Per event overrides, for things like amplitude sessionId, for example\n      ...event.options?.integrations,\n    }\n\n    const [context, overrides] = this.context(event)\n    const { options, ...rest } = event\n\n    const body = {\n      timestamp: new Date(),\n      ...rest,\n      context,\n      integrations: allIntegrations,\n      ...overrides,\n    }\n\n    const messageId = 'ajs-next-' + md5.hash(JSON.stringify(body) + uuid())\n\n    const evt: SegmentEvent = {\n      ...body,\n      messageId,\n    }\n\n    return evt\n  }\n}\n"]},"metadata":{},"sourceType":"module"}